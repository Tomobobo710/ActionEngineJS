<!DOCTYPE html>
<html>
<head>
    <title>WebGPU Subdivided Cube</title>
    <style>
        canvas {
            width: 800px;
            height: 600px;
            background: #000;
        }
    </style>
</head>
<body>
    <canvas id="gpuCanvas"></canvas>
    <script type="module">
        async function init() {
            const canvas = document.querySelector('#gpuCanvas');
            
            const devicePixelRatio = window.devicePixelRatio || 1;
            canvas.width = canvas.clientWidth * devicePixelRatio;
            canvas.height = canvas.clientHeight * devicePixelRatio;

            if (!navigator.gpu) {
                throw new Error('WebGPU not supported');
            }

            const adapter = await navigator.gpu.requestAdapter();
            const device = await adapter.requestDevice();
            const context = canvas.getContext('webgpu');

            const format = navigator.gpu.getPreferredCanvasFormat();
            context.configure({
                device,
                format,
                alphaMode: 'premultiplied',
            });

            const vertexShaderCode = `
                struct Uniforms {
                    modelViewProj: mat4x4<f32>,
                    time: f32,
                }
                @binding(0) @group(0) var<uniform> uniforms: Uniforms;

                struct VertexOutput {
                    @builtin(position) position: vec4<f32>,
                    @location(0) color: vec3<f32>,
                };

                @vertex
                fn main(
                    @location(0) position: vec3<f32>,
                    @location(1) color: vec3<f32>
                ) -> VertexOutput {
                    var output: VertexOutput;
                    
                    // Animate vertices
                    var pos = position;
                    let dist = length(pos.xy);
                    let wave = sin(uniforms.time * 2.0 + dist * 3.0) * 0.1;
                    pos = pos * (1.0 + wave);
                    
                    output.position = uniforms.modelViewProj * vec4<f32>(pos, 1.0);
                    output.color = color + wave;
                    return output;
                }
            `;

            const fragmentShaderCode = `
                @fragment
                fn main(@location(0) color: vec3<f32>) -> @location(0) vec4<f32> {
                    return vec4<f32>(color, 1.0);
                }
            `;

            const pipeline = device.createRenderPipeline({
                layout: 'auto',
                vertex: {
                    module: device.createShaderModule({ code: vertexShaderCode }),
                    entryPoint: 'main',
                    buffers: [{
                        arrayStride: 24,
                        attributes: [
                            { shaderLocation: 0, offset: 0, format: 'float32x3' },  // position
                            { shaderLocation: 1, offset: 12, format: 'float32x3' }  // color
                        ]
                    }]
                },
                fragment: {
                    module: device.createShaderModule({ code: fragmentShaderCode }),
                    entryPoint: 'main',
                    targets: [{ format }]
                },
                primitive: {
                    topology: 'triangle-list',
                    cullMode: 'back'
                },
                depthStencil: {
                    depthWriteEnabled: true,
                    depthCompare: 'less',
                    format: 'depth24plus'
                }
            });

            // Create subdivided cube
            const subdivisions = 4;  // subdivisions per face edge
            const vertices = [];
            const indices = [];

            function addFace(baseX, baseY, baseZ, dirX, dirY, dirZ, upX, upY, upZ, color) {
                const baseIndex = vertices.length / 6;
                
                for(let i = 0; i <= subdivisions; i++) {
                    for(let j = 0; j <= subdivisions; j++) {
                        const x = baseX + (dirX * i/subdivisions) + (upX * j/subdivisions);
                        const y = baseY + (dirY * i/subdivisions) + (upY * j/subdivisions);
                        const z = baseZ + (dirZ * i/subdivisions) + (upZ * j/subdivisions);
                        
                        vertices.push(x, y, z);  // position
                        vertices.push(color[0], color[1], color[2]);  // color
                    }
                }

                for(let i = 0; i < subdivisions; i++) {
                    for(let j = 0; j < subdivisions; j++) {
                        const topLeft = baseIndex + i * (subdivisions + 1) + j;
                        const topRight = topLeft + 1;
                        const bottomLeft = topLeft + (subdivisions + 1);
                        const bottomRight = bottomLeft + 1;

                        indices.push(topLeft, bottomLeft, topRight);
                        indices.push(bottomLeft, bottomRight, topRight);
                    }
                }
            }

            // Create cube faces
            
// Create cube faces - scale them down by using 0.5 instead of 1:
addFace(-0.5, -0.5, 0.5,   1, 0, 0,   0, 1, 0,   [1, 0, 0]);  // front
addFace(-0.5, -0.5, -0.5,  1, 0, 0,   0, 1, 0,   [0, 1, 0]);  // back
addFace(-0.5, -0.5, -0.5,  1, 0, 0,   0, 0, 1,   [0, 0, 1]);  // bottom
addFace(-0.5, 0.5, -0.5,   1, 0, 0,   0, 0, 1,   [1, 1, 0]);  // top
addFace(-0.5, -0.5, -0.5,  0, 1, 0,   0, 0, 1,   [1, 0, 1]);  // left
addFace(0.5, -0.5, -0.5,   0, 1, 0,   0, 0, 1,   [0, 1, 1]);  // right

            const vertexBuffer = device.createBuffer({
                size: vertices.length * 4,
                usage: GPUBufferUsage.VERTEX,
                mappedAtCreation: true,
            });
            new Float32Array(vertexBuffer.getMappedRange()).set(vertices);
            vertexBuffer.unmap();

            const indexBuffer = device.createBuffer({
                size: indices.length * 2,
                usage: GPUBufferUsage.INDEX,
                mappedAtCreation: true,
            });
            new Uint16Array(indexBuffer.getMappedRange()).set(indices);
            indexBuffer.unmap();

            const uniformBufferSize = 80;  // 4x4 matrix (64) + float (4) + padding (12)
            const uniformBuffer = device.createBuffer({
                size: uniformBufferSize,
                usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST
            });

            const bindGroup = device.createBindGroup({
                layout: pipeline.getBindGroupLayout(0),
                entries: [{
                    binding: 0,
                    resource: { buffer: uniformBuffer }
                }]
            });

            const depthTexture = device.createTexture({
                size: [canvas.width, canvas.height],
                format: 'depth24plus',
                usage: GPUTextureUsage.RENDER_ATTACHMENT
            });

            function getTransformationMatrix(time) {
                const aspect = canvas.width / canvas.height;
                const projectionMatrix = new Float32Array(16).fill(0);
                const viewMatrix = new Float32Array(16).fill(0);
                const modelMatrix = new Float32Array(16).fill(0);
                
                // Simple projection
             const fov = Math.PI / 3;
                const f = 1.0 / Math.tan(fov / 2);
                projectionMatrix[0] = f / aspect;
                projectionMatrix[5] = f;
                projectionMatrix[10] = -1;
                projectionMatrix[11] = -1;
                projectionMatrix[14] = -10;
                
                // View matrix (camera position)
                const radius = 4;
                const cameraX = radius * Math.sin(time * 0.5);
                const cameraZ = radius * Math.cos(time * 0.5);
                viewMatrix[0] = 1;
                viewMatrix[5] = 1;
                viewMatrix[10] = 1;
                viewMatrix[12] = -cameraX;
                viewMatrix[14] = -cameraZ;
                viewMatrix[15] = 1;
                
                // Model rotation
                const c = Math.cos(time);
                const s = Math.sin(time);
                modelMatrix[0] = c;
                modelMatrix[2] = -s;
                modelMatrix[5] = 1;
                modelMatrix[8] = s;
                modelMatrix[10] = c;
                modelMatrix[15] = 1;
                
                // Combine matrices
                const mvpMatrix = new Float32Array(16);
                for (let i = 0; i < 4; i++) {
                    for (let j = 0; j < 4; j++) {
                        let sum = 0;
                        for (let k = 0; k < 4; k++) {
                            sum += projectionMatrix[i * 4 + k] * viewMatrix[k * 4 + j];
                        }
                        mvpMatrix[i * 4 + j] = sum;
                    }
                }
                
                return mvpMatrix;
            }

            function render() {
                const time = performance.now() / 1000;

                // Update uniforms
                const transformationMatrix = getTransformationMatrix(time);
                device.queue.writeBuffer(uniformBuffer, 0, transformationMatrix.buffer);
                device.queue.writeBuffer(uniformBuffer, 64, new Float32Array([time]));

                const commandEncoder = device.createCommandEncoder();
                const textureView = context.getCurrentTexture().createView();

                const renderPass = commandEncoder.beginRenderPass({
                    colorAttachments: [{
                        view: textureView,
                        clearValue: { r: 0.1, g: 0.1, b: 0.1, a: 1.0 },
                        loadOp: 'clear',
                        storeOp: 'store',
                    }],
                    depthStencilAttachment: {
                        view: depthTexture.createView(),
                        depthClearValue: 1.0,
                        depthLoadOp: 'clear',
                        depthStoreOp: 'store',
                    }
                });

                renderPass.setPipeline(pipeline);
                renderPass.setBindGroup(0, bindGroup);
                renderPass.setVertexBuffer(0, vertexBuffer);
                renderPass.setIndexBuffer(indexBuffer, 'uint16');
                renderPass.drawIndexed(indices.length);
                renderPass.end();

                device.queue.submit([commandEncoder.finish()]);
                requestAnimationFrame(render);
            }

            requestAnimationFrame(render);
        }

        init();
    </script>
</body>
</html>