User: So, I have this demo/document for a game engine I have been working on:

```
/**
 * Welcome to the Action Engine!
 * The Action Engine simplifies the game development process by abstracting away the complexities of setting up and managing common "video game" software components. These vital systems can be tedious to implement, and really take the fun out of game development.
 * All essential systems are already initialized by Action Engine, including input, audio, and other background systems to allow developers to bypass several frustrating hurdles associated with creating and maintaining these neccesary (but boring) software mechanisms.
 * This allows the developer to focus on one thing: THE GAME! With the messy stuff out of the way, we can get right to the fun part!
 * The following DEMO is just an EXAMPLE of how to work with the Action Engine. All systems are well documented and heavily explained so there's no guesswork. By the end of this reading, you'll be a game making pro.
 * So dive in and start creating a masterpiece!
 */

/** THE GAME CLASS
 * The Game class is the heart of the Action Engine and serves as the entry point for your game.
 * Action Engine aims to let developers work in a way where the only domain is the Game class.
 * It is the ONLY required class, but any classes that will become intertwined with Game are welcome. Speaking of dependancies..
 * Like many popular game engines, Action Engine supplies three fully featured mathematic classes to assist with common video game operations.
 * There are 3 engine-provided math classes that the developer can depend on. `Vector2` `Vector3` and `Matrix4`. These are fully-featured, though not fully demonstrated.
 * Along with input and audio, these are the ONLY additonal classes that fall within the developer's expected available API playground.
 * There will still need to be some heavy lifting with any other classes, logic, or math that needs to be handled on a game by game basis.
 */

/**
 * class Game {}
 *
 * When the Game class is constructed, Action Engine will pass necessary information like rendering canvases and references to the input and audio systems.
 * The developer can easily integrate with and control these systems without worrying about configuration or maintenance, just focus on the game logic (and rendering).
 **/
class Game {
	/******* Action Engine Game Class Constructor *******/
	constructor(canvases, input, audio) {
		/*********
		 * Action Engine requires the Game constructor to accept the following parameters:
		 *
		 * `canvases`: An object with three properties - gameCanvas, guiCanvas, and debugCanvas
		 * These are the three layers that make up the Action Engine canvas rendering system
		 * The canvases are automatically created and managed in the background, no need to setup your screen or anything related to window sizes or anything, it's all handled
		 * This system allows for easy and clear separation of UI elements and actual game content, which is often a headache especially when prototyping and needing to come back to add additional layers
		 * The guiCanvas and debugCanvas are set by the engine to be 2d contexts, to always give developers an option for 2d overlays
		 * The guiCanvas is an optional layer that is by default hidden, but can be toggled with the (ActionDebugToggle) key (defaulted to f9) allowing for the developer to have a clear and separated canvas for debug related info
		 * This separation allows for the developer to choose whether they want a 2d or 3d game with 2d overlays, there is plenty of room for everything
		 *
		 * `input`: The input system of the Action Engine
		 * This system seamlessly handles keyboard, mouse, and touch input in the background
		 * It provides an automatic and intuitive way for developers to detect input from a variety ofstandard input devices
		 * This allows the developer to worry less about what key does what or how the UI is handled, or the hassles of trying to implement addtional input device support, it's already done!
		 * To interface with the input system, Action Engine has a simple to use API which we will be showcased here in this DEMO.
		 *
		 * `audio`: The audio system of the Action Engine
		 * Sound really AMPS up a game's presentation!
		 * Action Engine handles sound generation and playback, and provides a simple and intuitive way for developers to add sound effects and music to their game.
		 * The audio setup is alreay handled at the engine level. Sound creation is very flexible, there is even midi instrument sample support for high quality sounds, so you don't need to search around on any sketchy sites for questionably royalty free .wav files
		 * But that's not all! The developer can get creative with the synth sampling and other sound types through an easy to use API, which will be demonstrated in the sound creation part of this demo
		 * All that in one line?!?!? That's the power of Action Engine. Let's go on a journey through the demo together!
		 **/

		/************ Core Systems ************/

		// Canvas initialization

		// The DEMO stores references to core engine systems
		this.input = input; // Handles keyboard, mouse, and touch input
		this.audio = audio; // Manages sound generation and playback

		// The main "game" layer
		this.canvas = canvases.gameCanvas; // This will always be 3D

		// The two additional canvases
		this.guiCanvas = canvases.guiCanvas; // !!!ALWAYS 2D!!! overlay for UI elements like menus and HUD
		this.debugCanvas = canvases.debugCanvas; // !!!ALWAYS 2D!!! overlay for development/debugging visualization

		// The GUI Context (2D overlay)
		this.guiCtx = canvases.guiCtx; // Always a 2D context for UI elements

		// The Debug Context (2D overlay)
		this.debugCtx = canvases.debugCtx; // Always a 2D context for debugging

		/************ Initialize 3D System ************/
		// Initialize 3D renderer - this handles all WebGL complexity for us!
		this.renderer3D = new ActionRenderer3D(this.canvas);

		// Initialize shader manager - manages all shader programs
		this.shaderManager = new ShaderManager(this.renderer3D);

		// Initialize physics world - handles all physics calculations
		this.physicsWorld = new ActionPhysicsWorld3D(this.shaderManager);

		// Setup camera - starts in free mode until character is spawned
		this.camera = new ActionCamera();
		this.camera.position = new Vector3(0, 15, -30);
		this.camera.target = new Vector3(0, 0, 0);
		this.camera.isDetached = true; // Set camera to detached mode initially

		// Player is null until spawned
		this.player = null;

		/******** Debug Overlay Configuration ********/
		// Configuration options for the debug overlay
		// This layer displays debug info and hosts our 2D mini-game when toggled!
		this.messages = []; // Array of debug messages to display
		this.maxMessages = 20; // Maximum number of messages to keep in history
		this.lineHeight = 20; // Vertical pixels between debug message lines
		this.padding = 10; // Padding around debug message area
		this.showDebug = false; // Toggle debug overlay visibility

		/*********** Demo Stats Tracking ************/
		// The DEMO tracks click stats for the purpose of demonstrating some simple game logic
		this.totalClicks = 0; // Count of total button clicks
		this.totalButtons = 4; // Number of interactive buttons (includes spawn button)

		/*********** 2D Game Elements (for debug overlay) ************/
		// Here the DEMO utilizes the built-in Vector2 class to setup the playable 2D character
		// Ship properties (for the 2D game that appears behind debug overlay)
		this.shipPosition = Vector2.create(Game.WIDTH / 2, Game.HEIGHT / 2); // Engine provides Vector2 classes for common 2D operations
		this.shipRotation = 0; // in radians
		this.shipVelocity = Vector2.create();
		this.shipDirection = Vector2.create(0, -1); // Pointing up initially
		this.rotationSpeed = 0.05;
		this.thrust = 0.05;
		this.friction = 0.98;

		// Soccer ball properties (for the 2D game)
		this.ballPosition = Vector2.create(300, 300);
		this.ballVelocity = Vector2.create(2, 1);
		this.ballRadius = 20;
		this.ballRotation = 0;
		this.ballSpinSpeed = 0.03;

		// Last time for delta time calculation
		this.lastTime = performance.now();

		/*********** Initializing Demo Components ********/
		// Set up basic 3D physics objects
		this.setupDemoObjects();

		// Initialize GUI elements and interactive buttons
		this.initializeInteractiveElements();

		// Create sounds for the demo
		this.createGameSounds();

		console.log("[Demo Game] Initialization completed");
	}

	/******* Fixed Coordinate System *******
	 * Internally, the Action Engine uses an 800x600 canvas using fixed dimensions.
	 * The DEMO uses this to it's advantage to reference and position everything by these constants.
	 * This allows for the developer to be worry free about resolution scaling or any of the headaches that come
	 * with viewports, different screen sizes, canvas scaling, aspect ratio, and the like. Forget about it!
	 * Action Engine uses a fixed 4:3 aspect ratio and handles all window resizing and other internal "screen"
	 * handling, leaving the developer a simple way to manage positioning that is straight forward.
	 * In the DEMO, these are stored and are put to use in future positioning calculations:
	 *******/
	static WIDTH = 800;
	static HEIGHT = 600;

	/**
	 * Sets up the basic physics objects for the 3D scene
	 */
	setupDemoObjects() {
		// Create essential shapes for our 3D world
		this.ground = this.createGround();
		this.box = this.createBox();
		this.sphere = this.createSphere();

		this.addMessage("[Game] Created basic physics objects");
	}

	/**
	 * Here the DEMO Adds a timestamped message to the debug message queue
	 * Maintains maximum message limit by removing oldest messages to display on the debugCanvas
	 */
	addMessage(msg) {
		this.messages.unshift(`[${new Date().toLocaleTimeString()}] ${msg}`);
		if (this.messages.length > this.maxMessages) {
			this.messages.pop();
		}
	}

	/*** Physics object creation methods ***/

	// Create a box with physics
	createBox(width = 5, height = 5, depth = 5, mass = 1, position = new Vector3(0, 15, 0)) {
		const box = new ActionPhysicsBox3D(this.physicsWorld, width, height, depth, mass, position);
		this.physicsWorld.addObject(box);
		return box;
	}

	// Create a sphere with physics
	createSphere(radius = 3, mass = 1, position = new Vector3(8, 20, 0)) {
		const sphere = new ActionPhysicsSphere3D(this.physicsWorld, radius, mass, position);
		this.physicsWorld.addObject(sphere);
		return sphere;
	}

	// Create a ground plane (actually just a flat box)
	createGround(size = 100, position = new Vector3(0, -0.5, 0)) {
		// Simply use our box creation method with a flat box shape
		// Using 0 mass to make it static (won't move)
		return this.createBox(
			size, // width - very wide
			1, // height - just 1 unit tall
			size, // depth - very deep
			0, // mass - 0 means static object
			position // position - slightly below zero by default
		);
	}

	// Create a random physics object at the given position
	createRandomObject(position) {
		// Simple random object creation - just boxes and spheres
		const objectType = Math.random() > 0.5 ? 0 : 1;

		switch (objectType) {
			case 0: // Sphere
				const sphereRadius = Math.random() * 3 + 1; // radius between 1-4
				const sphereMass = Math.random() * 5 + 1; // mass between 1-6
				return this.createSphere(sphereRadius, sphereMass, position);

			case 1: // Box
				const boxWidth = Math.random() * 4 + 2; // width between 2-6
				const boxHeight = Math.random() * 4 + 2; // height between 2-6
				const boxDepth = Math.random() * 4 + 2; // depth between 2-6
				const boxMass = Math.random() * 5 + 1; // mass between 1-6
				return this.createBox(boxWidth, boxHeight, boxDepth, boxMass, position);
		}
	}

	/**
	 * Spawn a character in the 3D world
	 */
	spawnCharacter() {
		// Create new character if one doesn't exist
		if (!this.player) {
			this.addMessage("Spawning 3D character");

			// Initialize first/3rd person character controller
			this.player = new ActionCharacter3D(this.camera, this);
			this.physicsWorld.objects.add(this.player.characterModel);

			// Position the character in a good starting location
			if (this.player.characterModel && this.player.characterModel.body) {
				this.player.characterModel.body.position.set(0, 5, 0);
			}

			// Connect camera to player
			this.camera.isDetached = false;

			// Play spawn sound
			this.audio.play("spawnSound");
		}
	}

	/**
	 * action_update() - Hook called by the App class each frame
	 */
	action_update() {
		// Calculate delta time
		const currentTime = performance.now();
		const deltaTime = Math.min((currentTime - this.lastTime) / 1000, 0.25); // Cap at 250ms
		this.lastTime = currentTime;

		// Call our update method with the calculated delta time
		this.update(deltaTime);
	}

	/**
	 * action_draw() - Hook called by the App class each frame after update
	 */
	action_draw() {
		// Call our draw method
		this.draw();
	}
	/*-----------------
	 * THE THREE-LAYER INPUT SYSTEM:
	 * -----------------
	 * Action Engine uses a sophisticated three-layer input system that mimics how a typical
	 * game's interface is (ideally) structured:
	 *
	 * DEBUG LAYER (Top) -> GUI LAYER (Middle) -> GAME LAYER (Bottom)
	 *
	 * When input events occur, they cascade through these layers in order. If an upper
	 * layer handles the event (like clicking a debug button), lower layers won't receive it.
	 * This prevents background elements from catching input meant for UI or debug controls.
	 *
	 * Each registered element maps to a specific rendering layer, defaulting to:
	 *
	 * - GUI elements (guiCanvas): Menus, HUD, interface components
	 *
	 * The guiCanvas is the default layer target when no explicit layer parameter is passed to registerElement()
	 *
	 * Elements targeting non-default layers require explicit layer specification in registerElement():
	 *
	 * - Debug elements (debugCanvas): Debugging tools, development overlays  [layer='debug']
	 * - Game elements (gameCanvas): In-game objects, playfield interactions  [layer='game']
	 *
	 * The DEMO shows this by having elements on all three layers:
	 * - A debug toggle button on the debug layer
	 * - Menu buttons on the GUI layer
	 * - Clickable game elements on the game layer
	 *
	 * When registering elements, developers can specify which layer they belong to:
	 * registerElement('buttonId', element, 'gui')  // Default layer
	 * registerElement('gameObject', element, 'game')
	 * registerElement('debugButton', element, 'debug')
	 *
	 * Pointer coordinates are automatically translated between layers, so developers
	 * don't need to handle different coordinate spaces or canvas scaling. The input
	 * system provides consistent coordinates across all layers.
	 */

	/**
	 * initializeInteractiveElements()
	 */
	initializeInteractiveElements() {
		/******* BUTTON TEMPLATE SETUP *******/
		// Create a shared template for consistent button styling
		// The developer could have different templates for different button types
		const buttonTemplate = {
			width: 120, // Standard button width - you can customize these!
			height: 40, // Standard button height
			color: "#00f0f0", // Default button color
			hovered: false // Tracks mouse hover state for visual feedback
		};

		/******* CENTERED BUTTON CREATION *******/
		// Main button demonstrates screen-centered positioning
		// Uses Game.WIDTH/HEIGHT for reliable positioning regardless of screen size
		this.button1 = {
			...buttonTemplate, // Use our template as base
			x: (Game.WIDTH - buttonTemplate.width) / 2, // Center horizontally
			y: (Game.HEIGHT - buttonTemplate.height) / 2, // Center vertically
			text: "Click Me 1" // Button label
		};

		/******* FIXED POSITION BUTTONS *******/
		// Secondary buttons showing absolute positioning
		this.button2 = {
			...buttonTemplate,
			x: 340, // Fixed x position
			y: 180, // Fixed y position
			text: "Click Me 2"
		};

		this.button3 = {
			...buttonTemplate,
			x: 340,
			y: 80,
			text: "Click Me 3"
		};

		/******* INACTIVE BUTTON CREATION *******/
		// Create a special button to demonstrate the active/inactive element system
		// This button starts in a disabled state and can be toggled by Button 1
		// Uses different colors to provide clear visual feedback of its current state
		this.inactiveButton = {
			...buttonTemplate, // Share standard button properties
			x: 340, // Fixed x position
			y: 480, // Positioned below other buttons
			text: "Inactive", // Label indicates its purpose
			isActive: false, // Start in disabled state
			color: "#666666" // Grayed out when inactive
		};

		/******* 3D CHARACTER SPAWN BUTTON *******/
		// Create a button to spawn the 3D character
		// This is a key feature of the updated demo
		this.spawnButton = {
			...buttonTemplate,
			width: 200, // Wider than standard buttons
			x: (Game.WIDTH - 200) / 2, // Center horizontally
			y: Game.HEIGHT - 80, // Position near bottom of screen
			text: "Spawn Character", // Clear action label
			color: "#00f0f0" // Matching our color scheme
		};

		/******* INPUT SYSTEM REGISTRATION *******/
		// Register buttons with input system for interaction tracking
		// The bounds function lets the input system know where each button is
		// In the background, action engine has a clearly defined cascading input system
		// Events flow from debugCanvas -> guiCanvas -> gameCanvas, in that order

		// Register main game button
		this.input.registerElement("button1", {
			bounds: () => ({
				// Bounds provided as function for dynamic updates
				x: this.button1.x, // Current x position
				y: this.button1.y, // Current y position
				width: this.button1.width, // Button width
				height: this.button1.height // Button height
			})
		});

		// Register secondary buttons same way
		this.input.registerElement("button2", {
			bounds: () => ({
				x: this.button2.x,
				y: this.button2.y,
				width: this.button2.width,
				height: this.button2.height
			})
		});

		this.input.registerElement("button3", {
			bounds: () => ({
				x: this.button3.x,
				y: this.button3.y,
				width: this.button3.width,
				height: this.button3.height
			})
		});

		// Add inactive button to input tracking system
		// Even when inactive, the element's bounds are still tracked
		this.input.registerElement("inactiveButton", {
			bounds: () => ({
				x: this.inactiveButton.x,
				y: this.inactiveButton.y,
				width: this.inactiveButton.width,
				height: this.inactiveButton.height
			})
		});

		// Register the spawn button
		this.input.registerElement("spawnButton", {
			bounds: () => ({
				x: this.spawnButton.x,
				y: this.spawnButton.y,
				width: this.spawnButton.width,
				height: this.spawnButton.height
			})
		});

		/******* DEBUG LAYER BUTTON *******/
		// Create a button specifically for the debug layer
		// Shows how to work with different canvas layers
		this.debugButton = {
			x: Game.WIDTH - 130, // Position from right edge
			y: Game.HEIGHT - 50, // Position from bottom
			width: 120,
			height: 40,
			text: "Hide GUI", // Toggle button text
			color: "#ff4444", // Different color for visibility
			hovered: false,
			guiHidden: false // Track GUI visibility state
		};

		/******* GAME LAYER ELEMENT *******/
		// Create an interactive element in the game layer
		this.gameElement = {
			x: 600,
			y: 100,
			width: 100,
			height: 100,
			text: "Stop Sounds", // Careful with text rendering in 3D context!
			color: "#44ff44",
			hovered: false
		};

		/******* REGISTER LAYER-SPECIFIC ELEMENTS *******/
		// Register elements to specific layers for proper interaction handling

		// Debug layer button registration
		this.input.registerElement(
			"debugButton",
			{
				bounds: () => ({
					x: this.debugButton.x,
					y: this.debugButton.y,
					width: this.debugButton.width,
					height: this.debugButton.height
				})
			},
			"debug"
		); // Specify debug layer

		// Game layer element registration
		this.input.registerElement(
			"gameElement",
			{
				bounds: () => ({
					x: this.gameElement.x,
					y: this.gameElement.y,
					width: this.gameElement.width,
					height: this.gameElement.height
				})
			},
			"game"
		); // Specify game layer
	}

	/*
	 * update()
	 * The beating heart of the DEMO! This method handles all the logic updates
	 * including input handling, physics, and game state changes.
	 */
	update(deltaTime) {
		// Handle all common input interactions first
		this.handleCommonInput();

		// Route inputs based on debug overlay state (smart input routing)
		if (this.showDebug) {
			// When debug is visible, update 2D game
			this.update2DGame(deltaTime);
		} else {
			// When debug is not visible, update 3D world
			this.update3DWorld(deltaTime);
		}

		// Always update button states regardless of debug state
		this.updateButtonStates();
	}

	/**
	 * Handle 3D world updates and 3D character input
	 */

	update3DWorld(deltaTime) {
		// Update physics engine first
		this.physicsWorld.update(deltaTime);

		// If we have a player character, update it
		if (this.player) {
			// Let the character controller handle inputs for movement
			this.player.applyInput(this.input, deltaTime);
			this.player.update(deltaTime);
		} else {
			// Otherwise, control the free camera directly
			if (this.camera.isDetached) {
				this.camera.handleDetachedInput(this.input, deltaTime);
			}
		}

		// Check for Action3 to spawn random objects
		if (this.input.isKeyJustPressed("Action3")) {
			this.addMessage("Spawning random physics object");
			// Random position in the scene
			const randomX = Math.random() * 40 - 20; // -20 to 20
			const randomZ = Math.random() * 40 - 20; // -20 to 20
			const dropHeight = Math.random() * 10 + 20; // 20 to 30

			const randomPos = new Vector3(randomX, dropHeight, randomZ);
			this.createRandomObject(randomPos);
		}

		// Action2 to reset physics objects
		if (this.input.isKeyJustPressed("Action2")) {
			this.addMessage("Resetting physics world");
			this.physicsWorld.reset();

			// Re-add player if it exists
			if (this.player) {
				this.physicsWorld.objects.add(this.player.characterModel);

				// Reposition player after reset
				if (this.player.characterModel && this.player.characterModel.body) {
					this.player.characterModel.body.position.set(0, 5, 0);
				}
			}

			this.setupDemoObjects();
		}

		// Action1 is handled by the character controller internally when jumping
	}

	/**
	 * Update the 2D game that runs on the debug layer
	 */

	update2DGame(deltaTime) {
		/******* CONTINUOUS INPUT DETECTION *******/
		// When debug overlay is visible, we control the 2D game
		// These controls are similar to the original demo

		// DirectionalInput for ship movement
		if (this.input.isKeyPressed("DirUp")) {
			this.addMessage("DirUp IS PRESSED - Ship thrusting forward");
			const thrustVector = Vector2.create(this.shipDirection.x, this.shipDirection.y);
			thrustVector.scale(this.thrust);
			this.shipVelocity.add(thrustVector); // Add ship forward thrust
		}

		if (this.input.isKeyPressed("DirDown")) {
			this.addMessage("DirDown IS PRESSED - Ship reversing");
			const thrustVector = Vector2.create(this.shipDirection.x, this.shipDirection.y);
			thrustVector.scale(-this.thrust * 0.5); // Half power in reverse
			this.shipVelocity.add(thrustVector); // Add ship reverse thrust
		}

		if (this.input.isKeyPressed("DirLeft")) {
			this.addMessage("DirLeft IS PRESSED - Ship turning left");
			this.shipRotation -= this.rotationSpeed;
			this.shipDirection.rotate(-this.rotationSpeed); // Rotate ship left
		}

		if (this.input.isKeyPressed("DirRight")) {
			this.addMessage("DirRight IS PRESSED - Ship turning right");
			this.shipRotation += this.rotationSpeed;
			this.shipDirection.rotate(this.rotationSpeed); // Rotate ship right
		}

		// The DEMO plays sounds on isKeyJustPressed() to avoid repeated sound playback
		if (this.input.isKeyJustPressed("DirUp")) {
			this.addMessage("DirUp JUST pressed");
			this.audio.play("TrumpetCall");
		}

		if (this.input.isKeyJustPressed("DirDown")) {
			this.addMessage("DirDown JUST pressed");
			this.audio.play("PianoHit");
		}

		if (this.input.isKeyJustPressed("DirLeft")) {
			this.addMessage("DirLeft JUST pressed");
			this.audio.play("MidiSynthMix");
		}

		if (this.input.isKeyJustPressed("DirRight")) {
			this.addMessage("DirRight JUST pressed");
			this.audio.play("SimpleSong");
		}

		// Action buttons in 2D mode
		if (this.input.isKeyJustPressed("Action1")) {
			this.addMessage("Button 1 JUST pressed");
			this.audio.play("jump");
		}

		if (this.input.isKeyJustPressed("Action2")) {
			this.addMessage("Button 2 JUST pressed");
			this.audio.play("sound2");
		}

		if (this.input.isKeyJustPressed("Action3")) {
			this.addMessage("Button 3 JUST pressed");
			this.audio.play("sound3");
		}

		// Continuous check example
		if (this.input.isKeyPressed("Action4")) {
			this.addMessage("Button 4 IS PRESSED");
			this.audio.play("sound4"); // Will play repeatedly while held
		}

		// Apply ship physics
		this.shipPosition.add(this.shipVelocity);
		this.shipVelocity.scale(this.friction);

		// Wrap ship around screen
		if (this.shipPosition.x < 0) this.shipPosition.x = Game.WIDTH;
		if (this.shipPosition.x > Game.WIDTH) this.shipPosition.x = 0;
		if (this.shipPosition.y < 0) this.shipPosition.y = Game.HEIGHT;
		if (this.shipPosition.y > Game.HEIGHT) this.shipPosition.y = 0;

		// Update ball position
		this.ballPosition.add(this.ballVelocity);
		this.ballRotation += this.ballSpinSpeed;

		// Ball screen wrapping
		if (this.ballPosition.x < -this.ballRadius) this.ballPosition.x = Game.WIDTH + this.ballRadius;
		if (this.ballPosition.x > Game.WIDTH + this.ballRadius) this.ballPosition.x = -this.ballRadius;
		if (this.ballPosition.y < -this.ballRadius) this.ballPosition.y = Game.HEIGHT + this.ballRadius;
		if (this.ballPosition.y > Game.HEIGHT + this.ballRadius) this.ballPosition.y = -this.ballRadius;

		// Ship-ball collision detection
		const dx = this.shipPosition.x - this.ballPosition.x;
		const dy = this.shipPosition.y - this.ballPosition.y;
		const distance = Math.sqrt(dx * dx + dy * dy);

		if (distance < this.ballRadius + 20) {
			// 20 is approximate ship radius
			// Calculate collision angle
			const collisionAngle = Math.atan2(dy, dx);

			// Ball rebounds off ship
			const speed = Math.sqrt(
				this.ballVelocity.x * this.ballVelocity.x + this.ballVelocity.y * this.ballVelocity.y
			);
			this.ballVelocity.x = -Math.cos(collisionAngle) * speed;
			this.ballVelocity.y = -Math.sin(collisionAngle) * speed;

			// Add ship's velocity to ball
			this.ballVelocity.add(this.shipVelocity);

			// Play bounce sound
			this.audio.play("sound3");
		}
	}

	/**
	 * Handle input that applies regardless of debug/game state
	 */

	handleCommonInput() {
		/******* THE SPECIAL DEBUG KEY *******/
		// The engine-level ActionDebugToggle key toggles the debugCanvas visibility
		// In our updated demo, this also switches between 2D and 3D gameplay
		if (this.input.isKeyJustPressed("ActionDebugToggle")) {
			this.showDebug = !this.showDebug;
			this.addMessage(this.showDebug ? "Debug mode ON - 2D game active" : "Debug mode OFF - 3D world active");

			if (!this.showDebug) {
				this.debugCtx.clearRect(0, 0, Game.WIDTH, Game.HEIGHT);
			}
		}

		/******* POINTER CHECKING *******/
		// Get precise pointer coordinates in game space
		const pointerPos = this.input.getPointerPosition();
		if (pointerPos.x !== this.lastPointerX || pointerPos.y !== this.lastPointerY) {
			this.addMessage(`Pointer at: ${Math.round(pointerPos.x)}, ${Math.round(pointerPos.y)}`);
			this.lastPointerX = pointerPos.x;
			this.lastPointerY = pointerPos.y;
		}

		// Check if the pointer is down (clicked/touched)
		if (this.input.isPointerJustDown()) {
			this.addMessage("Pointer JUST pressed");
		}

		// Track UI Controls
		if (this.input.isUIButtonJustPressed("soundToggle")) {
			this.addMessage("Sound button toggled");
		}

		if (this.input.isUIButtonJustPressed("fullscreenToggle")) {
			this.addMessage("Fullscreen button toggled");
		}

		if (this.input.isUIButtonJustPressed("controlsToggle")) {
			this.addMessage("Controls button toggled");
		}

		if (this.input.isUIButtonJustPressed("pauseButton")) {
			this.addMessage("Pause button toggled");
		}
	}

	/**
	 * Update button hover states and handle button interactions
	 */

	updateButtonStates() {
		// Track button hover states for visual feedback
		this.button1.hovered = this.input.isElementHovered("button1");
		this.button2.hovered = this.input.isElementHovered("button2");
		this.button3.hovered = this.input.isElementHovered("button3");
		this.inactiveButton.hovered = this.input.isElementHovered("inactiveButton");
		this.spawnButton.hovered = this.input.isElementHovered("spawnButton");
		this.debugButton.hovered = this.input.isElementHovered("debugButton", "debug");

		// Log edge-triggered hover events for demonstration
		if (this.input.isElementJustHovered("button1")) {
			this.addMessage("Button 1 JUST hovered");
		}

		// Handle button 1 press - toggles inactive button
		if (this.input.isElementJustPressed("button1")) {
			const newActiveState = !this.input.isElementActive("inactiveButton");
			this.input.state.elements.gui.get("inactiveButton").isActive = newActiveState;
			this.inactiveButton.color = newActiveState ? "#00f0f0" : "#666666";
			this.addMessage(`Inactive button ${newActiveState ? "enabled" : "disabled"}`);
			this.totalClicks++;
		}

		// Handle other button presses
		if (this.input.isElementJustPressed("button2")) {
			this.addMessage("Button 2 was just pressed!");
			this.audio.play("sound5");
			this.totalClicks++;
		}

		// Example of counting clicks vs continuous presses
		if (this.input.isElementJustPressed("button3")) {
			this.totalClicks++;
		}

		// Continuous press example
		if (this.input.isElementPressed("button3")) {
			this.addMessage("Button 3 is being held down");
			this.audio.play("sound6");
		}

		// Inactive button status tracking
		if (this.input.isElementPressed("inactiveButton")) {
			if (this.input.isElementActive("inactiveButton")) {
				this.addMessage("Clicking an active button!");
			} else {
				this.addMessage("Button is inactive - click Button 1 to activate it!");
			}
		}

		// Handle inactive button click when active
		if (this.input.isElementJustPressed("inactiveButton") && this.input.isElementActive("inactiveButton")) {
			this.audio.play("victory");
			this.totalClicks++;
		}

		// Handle game element press (stops all sounds)
		if (this.input.isElementJustPressed("gameElement", "game")) {
			this.audio.stopAllSounds();
			this.addMessage("gameCanvas element pressed! All sounds stopped.");
			this.totalClicks++;
		}

		// Handle debug button to toggle GUI visibility
		if (this.input.isElementJustPressed("debugButton", "debug")) {
			this.debugButton.guiHidden = !this.debugButton.guiHidden;
			this.debugButton.text = this.debugButton.guiHidden ? "Show GUI" : "Hide GUI";
			this.guiCanvas.style.display = this.debugButton.guiHidden ? "none" : "block";
			this.addMessage("Debug button toggled GUI visibility");
		}

		// Handle spawn button to create 3D character
		if (this.input.isElementJustPressed("spawnButton")) {
			this.spawnCharacter();
			this.totalClicks++;
		}
	} /*-----------------
	 * AUDIO INTEGRATION:
	 * -----------------
	 * Action Engine includes a powerful and flexible audio system for adding sound effects and music to your game.
	 *
	 * Sound in games is a critical part of the overall presentation, and it's often
	 * overlooked or pushed onto the back-burner due to a plethora of difficulties.
	 * The Action Engine audio system solves these common challenges with multiple synthesis methods:
	 *
	 * SYNTHESIS OPTIONS:
	 * - Basic Waveforms: Create simple tones using sine, triangle, and square waves
	 * - FM Synthesis: Generate rich, dynamic sounds through frequency modulation
	 * - Complex Synthesis: Layer multiple oscillators for full, harmonic sounds
	 * - Noise Generation: Create white, pink, or brown noise for effects
	 * - Frequency Sweeps: Create dramatic pitch slides and transitions
	 *
	 * MIDI CAPABILITIES:
	 * - Full 128-instrument library built-in
	 * - High quality sampled instruments from pianos to drums
	 * - Multi-channel playback support
	 * - No external sound files needed
	 *
	 * AUDIO CONTROL:
	 * - Real-time parameter control
	 * - Stereo panning
	 * - Volume envelopes (ADSR)
	 * - Effects processing (reverb, echo, filters)
	 * - Individual sound control (play(), stopSound('sound') and stopAllSounds())
	 *
	 * SEQUENCING:
	 * - SonicPi-style scripting for complex arrangements
	 * - Tempo and timing control
	 * - Multiple concurrent tracks
	 * - Effect chains and processing
	 *
	 * The DEMO maps various sounds to inputs to showcase these capabilities:
	 * - One-shot sound effects for edge-triggered actions
	 * - Different synthesis types for varied sound design
	 * - MIDI instrument playback
	 * - Complex musical arrangements
	 *
	 * Let's dive in and make some noise! ðŸŽµ
	 * -----------------
	 */

	/*-----------------
	 * createGameSounds()
	 * -----------------
	 */

	createGameSounds() {
		/*-----------------
		 * THE SOUND CREATION PLAYGROUND!
		 * -----------------
		 * This method demonstrates the various ways to create and manage sounds in the engine.
		 * We'll explore different synthesis methods and show how to build both simple effects
		 * and complex musical arrangements.
		 *
		 * The examples progress from simple to complex:
		 * 1. Basic waveform synthesis
		 * 2. FM synthesis for dynamic sounds
		 * 3. Multi-oscillator layered sounds
		 * 4. Noise and sweep effects
		 * 5. MIDI instrument playback
		 * 6. Full musical sequences
		 *
		 * Each sound type has its own use case:
		 * - Basic synthesis: UI sounds, simple effects
		 * - FM synthesis: Sci-fi sounds, complex tones
		 * - Multi-oscillator: Rich sound effects, musical notes
		 * - Noise/Sweeps: Environmental effects, transitions
		 * - MIDI: High quality musical elements
		 * - Sequences: Background music, complex events
		 *
		 * !!! OPTIMIZATION NOTE !!!
		 * Layer your sound complexity based on game needs:
		 * - Simple synthesis is very lightweight
		 * - MIDI instruments take more memory
		 * - Complex sequences need more processing
		 * Consider using simpler sounds for frequent events
		 * and save complex sounds for important moments
		 * -----------------
		 */

		/******* DIFFERENT SOUND TYPE CREATION *******/
		// Each of these methods demonstrates a different type of sound synthesis
		// available in the Action Engine audio system

		// FM (Frequency Modulation) synthesis creates rich, dynamic sounds
		// Great for sci-fi effects or complex tones
		this.audio.createFMSound("fmSound", {
			carrierFreq: 440, // Base frequency
			modulatorFreq: 100, // Modulating frequency
			modulationIndex: 100, // How intense the modulation is
			type: "sine", // Carrier wave type
			duration: 0.5,
			envelope: {
				attack: 0.1,
				decay: 0.2,
				sustain: 0.6,
				release: 0.2
			}
		});

		// Complex sounds combine multiple oscillators for rich harmonics
		// Perfect for creating full, layered sounds
		this.audio.createComplexSound("complexSound", {
			frequencies: [440, 880, 1320], // Stack of frequencies
			types: ["sine", "triangle", "square"], // Different wave types
			mix: [0.5, 0.3, 0.2], // Volume mix of each oscillator
			duration: 0.8,
			envelope: {
				attack: 0.1,
				decay: 0.2,
				sustain: 0.5,
				release: 0.3
			}
		});

		// Noise generation for effects like wind, water, explosions
		this.audio.createNoiseSound("noiseSound", {
			noiseType: "white", // white, pink, or brown noise
			duration: 0.5,
			envelope: {
				attack: 0.05,
				decay: 0.1,
				sustain: 0.7,
				release: 0.2
			},
			filterOptions: {
				frequency: 1000, // Filter cutoff frequency
				Q: 1, // Filter resonance
				type: "lowpass" // Filter type
			}
		});

		// Frequency sweeps for dramatic effects
		this.audio.createSweepSound("sweepSound", {
			startFreq: 200, // Starting frequency
			endFreq: 800, // Ending frequency
			type: "triangle", // Wave type
			duration: 0.6,
			envelope: {
				attack: 0.1,
				decay: 0.2,
				sustain: 0.4,
				release: 0.2
			}
		});

		/******* SIMPLE SOUND EFFECTS *******/
		// Let's start with a classic platformer jump!
		// Frequency sweep from low to high = nice 'jump' feeling
		this.audio.createSweepSound("jump", {
			startFreq: 220, // Start at A3
			endFreq: 880, // Sweep up to A5
			type: "triangle", // Triangle wave sounds nice and smooth
			duration: 0.25, // Quick and snappy
			envelope: {
				// Shape the sound's volume over time
				attack: 0.05, // Quick start
				decay: 0.1, // Fast falloff
				sustain: 0.8, // Hold most of the volume
				release: 0.1 // Quick end
			}
		});

		/******* DRAMATIC POWER-UP EFFECT *******/
		// Stack multiple oscillators for a rich, dramatic sound
		this.audio.createComplexSound("sound2", {
			frequencies: [440, 587, 880, 1174], // Stack of harmonious frequencies
			types: ["triangle", "sine", "triangle", "sine"], // Mix different waves
			mix: [0.4, 0.3, 0.2, 0.1], // Fade each higher frequency
			duration: 0.4,
			envelope: {
				attack: 0.01, // Almost instant attack
				decay: 0.2,
				sustain: 0.6,
				release: 0.19
			}
		});

		/******* RETRO GAME SOUNDS *******/
		// Create an SNES-style acceleration sound
		// Multiple oscillators create that classic 16-bit feel
		this.audio.createComplexSound("sound3", {
			frequencies: [220, 330, 440], // Power of three
			types: ["triangle", "square", "triangle"], // Mix of waves
			mix: [0.5, 0.2, 0.1], // Emphasize base frequency
			duration: 0.35,
			envelope: {
				attack: 0.08,
				decay: 0.15,
				sustain: 0.6,
				release: 0.12
			}
		});

		/******* FM SYNTHESIS MAGIC *******/
		// Use frequency modulation for otherworldly sounds
		// Great for sci-fi effects or mystery reveals
		this.audio.createFMSound("sound4", {
			carrierFreq: 185, // Base frequency
			modulatorFreq: 92.5, // Modulating frequency
			modulationIndex: 100, // How 'wild' the modulation gets
			type: "sine",
			duration: 0.6,
			envelope: {
				attack: 0.15, // Slow build
				decay: 0.25,
				sustain: 0.6,
				release: 0.2
			}
		});

		/******* TRANSFORMATION EFFECT *******/
		// Create an ethereal sound perfect for power-ups or transformations
		this.audio.createComplexSound("sound5", {
			frequencies: [220, 330, 440, 660], // Harmonious stack
			types: ["sine", "sine", "triangle", "sine"],
			mix: [0.4, 0.3, 0.2, 0.1], // Fade higher frequencies
			duration: 0.7,
			envelope: {
				attack: 0.2, // Slow, majestic build
				decay: 0.3,
				sustain: 0.4,
				release: 0.2
			}
		});

		/******* CRYSTAL SHIMMER *******/
		// High, bright frequencies create a sparkling effect
		this.audio.createComplexSound("sound6", {
			frequencies: [294, 370, 440], // High, bright frequencies
			types: ["sine", "triangle", "sine"],
			mix: [0.45, 0.35, 0.2],
			duration: 0.5,
			envelope: {
				attack: 0.1,
				decay: 0.2,
				sustain: 0.5,
				release: 0.2
			}
		});

		/******* VICTORY FANFARE *******/
		// A triumphant sound using multiple harmonious frequencies
		this.audio.createComplexSound("victory", {
			frequencies: [330, 440, 550, 660, 880],
			types: ["triangle", "sine", "triangle", "sine", "triangle"],
			mix: [0.3, 0.25, 0.2, 0.15, 0.1],
			duration: 0.7,
			envelope: {
				attack: 0.1,
				decay: 0.25,
				sustain: 0.5,
				release: 0.3
			}
		});

		/******* MIDI INSTRUMENT SHOWCASE *******/
		// Now let's play with some high-quality MIDI instruments!

		// Complex synth and pad mix
		this.audio.createSound(
			"MidiSynthMix",
			{
				script: `
			   use_bpm 120
			   sample :pad, note: 60, amp: 0.3, duration: 4
			   sample :soft_synth, note: 72, amp: 0.3
			   sleep 1
			   sample :soft_synth, note: 76, amp: 0.25
			   sleep 1
		   `,
				samples: {
					pad: {
						soundType: "midi",
						instrument: "pad_3_polysynth", // Rich, atmospheric pad
						amp: 0.3
					},
					soft_synth: {
						type: "sin", // Mix with synthetic sound
						frequency: 440,
						decay: 1.5,
						amp: 0.3
					}
				}
			},
			"sonicpi"
		);

		// Clean piano hit
		this.audio.createSound(
			"PianoHit",
			{
				script: `
			   use_bpm 120
			   sample :piano, note: 60, amp: 0.5
		   `,
				samples: {
					piano: {
						soundType: "midi",
						instrument: "acoustic_grand_piano", // Beautiful grand piano
						amp: 0.5
					}
				}
			},
			"sonicpi"
		);

		// Majestic trumpet call
		this.audio.createSound(
			"TrumpetCall",
			{
				script: `
			   use_bpm 120
			   sample :trumpet, note: 67, amp: 0.4
			   sleep 0.2
			   sample :trumpet, note: 72, amp: 0.5
		   `,
				samples: {
					trumpet: {
						soundType: "midi",
						instrument: "trumpet", // Bright, bold trumpet
						amp: 0.4
					}
				}
			},
			"sonicpi"
		);

		/******* FULL SONG DEMO *******/
		// Bringing it all together in a complete musical arrangement!
		this.audio.createSound(
			"SimpleSong",
			{
				script: `
			   use_bpm 80
			   
			   define :melody do
				   sample :piano, note: 67, amp: 0.4
				   sleep 2
				   sample :piano, note: 72, amp: 0.3
				   sleep 2
				   sample :bells, note: 84, amp: 0.2
				   sleep 2
				   sample :bells, note: 79, amp: 0.2
				   sleep 2
			   end
			   
			   8.times do
				   sample :bass, note: 48, amp: 0.4
				   sample :strings, note: 60, amp: 0.3, duration: 8
				   melody
			   end
		   `,
				samples: {
					piano: {
						soundType: "midi",
						instrument: "acoustic_grand_piano", // Main melody
						amp: 0.4
					},
					bells: {
						soundType: "midi",
						instrument: "tubular_bells", // Sparkly accents
						amp: 0.2
					},
					bass: {
						soundType: "midi",
						instrument: "acoustic_bass", // Strong bass line
						amp: 0.4
					},
					strings: {
						soundType: "midi",
						instrument: "string_ensemble_1", // Lush backing
						amp: 0.3
					}
				}
			},
			"sonicpi"
		);

		/******* CHARACTER SPAWN SOUND *******/
		// Create a sound for the spawn button click
		this.audio.createSweepSound("spawnSound", {
			startFreq: 300,
			endFreq: 600,
			type: "triangle",
			duration: 0.3,
			envelope: {
				attack: 0.05,
				decay: 0.1,
				sustain: 0.5,
				release: 0.15
			}
		});

		/*-----------------
		 * BONUS SOUND DESIGN GUIDE:
		 * -----------------
		 * Creating good game audio is both art and science. Here are some proven approaches
		 * for different common game sound needs:
		 *
		 * UI SOUNDS:
		 * - Keep them short (0.1s - 0.3s)
		 * - Use simple waveforms (sine or triangle)
		 * - Quick attack, minimal decay
		 * Example for a "select" sound:
		 */
		this.audio.createSweepSound("selectBlip", {
			startFreq: 440, // A4 note
			endFreq: 880, // Up to A5
			type: "sine", // Clean sine wave
			duration: 0.15, // Very short
			envelope: {
				attack: 0.01, // Almost immediate
				decay: 0.14, // Most of duration
				sustain: 0, // No sustain needed
				release: 0 // No release needed
			}
		});

		/*
		 * IMPACT SOUNDS:
		 * - Start with noise for the "hit"
		 * - Add a tonal element for character
		 * - Quick attack, medium decay
		 */
		this.audio.createComplexSound("impact", {
			frequencies: [100, 200, 300], // Low frequencies for impact
			types: ["square", "sine", "sine"], // Square wave adds "punch"
			mix: [0.6, 0.3, 0.1], // Emphasize lower frequencies
			duration: 0.4,
			envelope: {
				attack: 0.01, // Immediate hit
				decay: 0.2, // Quick falloff
				sustain: 0.2, // Some body
				release: 0.19 // Smooth end
			}
		});

		/*
		 * AMBIENT SOUNDS:
		 * - Use noise with heavy filtering
		 * - Longer durations
		 * - Smooth transitions
		 */
		this.audio.createNoiseSound("wind", {
			noiseType: "pink", // Pink noise sounds more natural
			duration: 2.0,
			envelope: {
				attack: 0.5, // Slow fade in
				decay: 0.5,
				sustain: 0.7, // Maintain presence
				release: 1.0 // Slow fade out
			},
			filterOptions: {
				frequency: 800, // Remove harsh high frequencies
				Q: 0.5, // Gentle resonance
				type: "lowpass"
			}
		});

		/*
		 * MUSICAL ELEMENTS:
		 * - Use FM synthesis for rich tones
		 * - Pay attention to musical intervals
		 * - Longer attack/release for smoothness
		 */
		this.audio.createFMSound("synthPad", {
			carrierFreq: 440, // Base note A4
			modulatorFreq: 220, // Modulate at half frequency
			modulationIndex: 50, // Moderate modulation
			type: "sine",
			duration: 1.0,
			envelope: {
				attack: 0.2, // Smooth fade in
				decay: 0.3,
				sustain: 0.6,
				release: 0.5
			}
		});

		/*
		 * EFFECT CHAINS:
		 * Action Engine supports chaining multiple effects. Some useful combinations:
		 *
		 * Spacious Atmosphere:
		 */
		const spaciousSound = {
			script: `
			use_bpm 60
			with_fx :reverb, room: 0.8 do
				with_fx :echo, phase: 0.5, decay: 2 do
					sample :pad_3_polysynth, note: 50, amp: 0.3
				end
			end
		`,
			samples: {
				pad: {
					soundType: "midi",
					instrument: "pad_3_polysynth",
					amp: 0.3
				}
			}
		};

		/*
		 * Power Up Effect:
		 */
		const powerUp = {
			script: `
			use_bpm 120
			with_fx :echo, phase: 0.125 do
				with_fx :wobble, phase: 0.5 do
					sample :synth_strings_1, note: 60
					sleep 0.25
					sample :synth_strings_1, note: 67
				end
			end
		`
		};

		/*
		 * COMMON PITFALLS TO AVOID:
		 * 1. Too much frequency overlap - space out your frequencies
		 * 2. Harsh attacks - use at least 0.01s attack time
		 * 3. Abrupt endings - always use some release time
		 * 4. Overusing effects - subtlety often works better
		 * 5. Too much low frequency content - can muddy the mix
		 */
	}

	/**
	 * drawButton(button)
	 *
	 * Renders a button with hover effects and centered text on the GUI layer
	 * @param {Object} button - The button object to render
	 *
	 * Before we got here, we stored some information on the "hover" state of our buttons class-wide.
	 * The DEMO will use the information it stores from the input state to draw the buttons in a different style when "hovered".
	 */

	drawButton(button) {
		// Use guiCtx instead of ctx since buttons are UI elements
		this.guiCtx.save();

		// Draw button background with "hover" effect
		this.guiCtx.fillStyle = button.hovered ? "#00b0b0" : button.color;
		this.guiCtx.strokeStyle = "#ffffff";
		this.guiCtx.lineWidth = 2;

		this.guiCtx.beginPath();
		this.guiCtx.roundRect(button.x, button.y, button.width, button.height, 8);
		this.guiCtx.fill();
		this.guiCtx.stroke();

		// Draw centered button text
		this.guiCtx.fillStyle = "#ffffff";
		this.guiCtx.font = "20px Orbitron";
		this.guiCtx.textAlign = "center";
		this.guiCtx.textBaseline = "middle";
		this.guiCtx.fillText(button.text, button.x + button.width / 2, button.y + button.height / 2);

		this.guiCtx.restore();
	}

	/**
	 * draw()
	 * Master drawing method that handles all rendering layers
	 */
	draw() {
		/*
		 * Action Engine supports both 2D and 3D rendering.
		 * The demo shows the potential of the three-layer system by separating drawing across these layers.
		 * Each layer serves a specific purpose, and the three-layer system allows for harmony.
		 */

		/******* GAME LAYER RENDERING *******/
		/*
		 * GAME LAYER (this.canvas):
		 * - This is now always 3D rendered
		 * - Handles the 3D world, character, and physics objects
		 */
		this.draw3DScene();

		/******* GUI LAYER RENDERING *******/
		/*
		 *  THE GUI LAYER (this.guiCtx):
		 * - Always 2D for crisp UI rendering
		 * - Intended use: Buttons, menus, HUD elements
		 * - Stays pixel-perfect regardless of game context
		 */
		this.drawGUILayer();

		/******* DEBUG LAYER RENDERING *******/
		/*
		 * THE DEBUG LAYER (this.debugCtx):
		 * - Development tools and debug info
		 * - Toggle with F9
		 * - Also hosts our 2D mini-game when visible!
		 * - Always renders on top
		 */
		if (this.showDebug) {
			this.drawDebugLayer();
		}

		{
		}
	} /**
	 * draw3DScene()
	 *
	 * Handles rendering the 3D world with all physics objects and characters
	 * Uses ActionEngine's 3D rendering system for clean, simplified 3D rendering
	 */
	draw3DScene() {
		// Clear the canvas
		const gl = this.canvas.getContext("webgl2") || this.canvas.getContext("webgl");
		if (gl) {
			gl.clearColor(0.529, 0.808, 0.922, 1.0); // Sky blue background
			gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
		}

		// Render the scene using ActionEngine's renderer
		this.renderer3D.render({
			renderableObjects: Array.from(this.physicsWorld.objects),
			camera: this.camera
		});
	}

	/**
	 * drawGUILayer()
	 *
	 * Renders all UI elements on the GUI layer
	 * The guiCanvas is a 2D context, providing crisp UI rendering regardless of game state
	 */
	drawGUILayer() {
		// Clear the GUI canvas
		this.guiCtx.clearRect(0, 0, this.guiCanvas.width, this.guiCanvas.height);

		/******* RENDER ALL BUTTONS *******/
		// Draw all interactive buttons including spawn character button
		[this.button1, this.button2, this.button3, this.inactiveButton, this.spawnButton].forEach((button) => {
			this.drawButton(button);
		});

		// Draw stats display
		this.drawStatsDisplay();

		// Draw 3D world instructions when debug overlay is not visible
		if (!this.showDebug) {
			this.drawInstructions();
		}
	}

	/**
	 * Draw gameplay instructions
	 */
	drawInstructions() {
		this.guiCtx.font = "16px Arial";
		this.guiCtx.fillStyle = "white";
		this.guiCtx.textAlign = "left";
		this.guiCtx.textBaseline = "top";

		this.guiCtx.fillText("3D World Demo with ActionEngine", 10, 10);

		if (this.player) {
			this.guiCtx.fillText("Action1: Jump (when character is on ground)", 10, 40);
			this.guiCtx.fillText("DirUp/Down/Left/Right: Move character", 10, 60);
			this.guiCtx.fillText("F9: Toggle debug overlay (switches to 2D mini-game)", 10, 80);
		} else {
			this.guiCtx.fillText("Use Arrow Keys to move the free camera", 10, 40);
			this.guiCtx.fillText("Click the 'Spawn Character' button to create a playable character", 10, 60);
			this.guiCtx.fillText("F9: Toggle debug overlay (switches to 2D mini-game)", 10, 80);
		}

		this.guiCtx.fillText("Action2: Reset all physics objects", 10, 100);
		this.guiCtx.fillText("Action3: Spawn random physics object", 10, 120);
		this.guiCtx.fillText(`Objects in world: ${this.physicsWorld.objects.size}`, 10, 140);

		// Display character debug info if available
		if (this.player && this.player.debugInfo) {
			const debugInfo = this.player.debugInfo;
			this.guiCtx.fillText(`Character state: ${debugInfo.state.current}`, 10, 170);
			this.guiCtx.fillText(
				`Position: (${debugInfo.physics.position.x.toFixed(2)}, ${debugInfo.physics.position.y.toFixed(2)}, ${debugInfo.physics.position.z.toFixed(2)})`,
				10,
				190
			);
			this.guiCtx.fillText(
				`Velocity: (${debugInfo.physics.velocity.x.toFixed(2)}, ${debugInfo.physics.velocity.y.toFixed(2)}, ${debugInfo.physics.velocity.z.toFixed(2)})`,
				10,
				210
			);
		}
	}

	/**
	 * drawDebugLayer()
	 *
	 * Renders the debug overlay and 2D game when the debug mode is active
	 * The debugCanvas hosts both debugging tools and our playable 2D mini-game
	 */
	drawDebugLayer() {
		// Clear the debug canvas
		this.debugCtx.clearRect(0, 0, this.debugCanvas.width, this.debugCanvas.height);

		// Draw debug background
		this.debugCtx.fillStyle = "rgba(0, 0, 0, 0.7)";
		this.debugCtx.fillRect(0, 0, this.debugCanvas.width, this.debugCanvas.height);

		// Draw the 2D game on the debug layer when debug is active
		this.draw2DGame();

		// Draw debug button
		this.drawDebugButton();

		// Draw message log
		this.drawDebugMessages();
	}

	/**
	 * draw2DGame()
	 *
	 * Renders the 2D space game on the debug layer when debug is toggled on
	 * This is the original 2D game from the demo, now running on the debug layer
	 */
	draw2DGame() {
		// Use the debug context for rendering
		const ctx = this.debugCtx;

		// Add a space-like background (semi-transparent to show debug layer)
		ctx.fillStyle = "rgba(0, 0, 51, 0.5)";
		ctx.fillRect(0, 0, this.debugCanvas.width, this.debugCanvas.height);

		// Draw ship
		ctx.save();
		ctx.translate(this.shipPosition.x, this.shipPosition.y);
		ctx.rotate(this.shipRotation);

		// Draw triangular ship
		ctx.beginPath();
		ctx.moveTo(0, -20); // nose
		ctx.lineTo(-15, 20); // left wing
		ctx.lineTo(15, 20); // right wing
		ctx.closePath();

		ctx.strokeStyle = "#00ff00";
		ctx.lineWidth = 2;
		ctx.stroke();

		// Draw thrust if moving forward
		if (this.input.isKeyPressed("DirUp") && this.showDebug) {
			ctx.beginPath();
			ctx.moveTo(-8, 20);
			ctx.lineTo(0, 30);
			ctx.lineTo(8, 20);
			ctx.strokeStyle = "#ff0000";
			ctx.stroke();
		}

		ctx.restore();

		// Draw soccer ball
		ctx.save();
		ctx.translate(this.ballPosition.x, this.ballPosition.y);
		ctx.rotate(this.ballRotation);

		// Create pseudo-3D effect with gradient
		const gradient = ctx.createRadialGradient(-5, -5, 1, -5, -5, this.ballRadius * 2);
		gradient.addColorStop(0, "#ffffff");
		gradient.addColorStop(1, "#cccccc");

		// Draw main ball circle
		ctx.beginPath();
		ctx.arc(0, 0, this.ballRadius, 0, Math.PI * 2);
		ctx.fillStyle = gradient;
		ctx.fill();

		// Draw pentagon pattern
		const segments = 5;
		const angleStep = (Math.PI * 2) / segments;
		for (let i = 0; i < segments; i++) {
			const angle = i * angleStep;

			ctx.beginPath();
			ctx.moveTo(0, 0);
			ctx.lineTo(Math.cos(angle) * this.ballRadius, Math.sin(angle) * this.ballRadius);
			ctx.lineTo(Math.cos(angle + angleStep) * this.ballRadius, Math.sin(angle + angleStep) * this.ballRadius);
			ctx.closePath();
			ctx.fillStyle = i % 2 === 0 ? "#000000" : "#ffffff";
			ctx.globalAlpha = 0.3;
			ctx.fill();
		}

		// Draw highlight
		ctx.beginPath();
		ctx.arc(-5, -5, this.ballRadius / 3, 0, Math.PI * 2);
		ctx.fillStyle = "rgba(255, 255, 255, 0.3)";
		ctx.fill();

		ctx.restore();

		// Add 2D game info
		ctx.fillStyle = "#00ff00";
		ctx.font = "14px monospace";
		ctx.fillText("Debug Mode Active - 2D Mini-Game Running", this.padding, this.padding + 50);
		ctx.fillText("Use Arrow Keys to control the ship", this.padding, this.padding + 70);
		ctx.fillText("Try to hit the ball with your ship!", this.padding, this.padding + 90);
	}

	/**
	 * drawDebugButton()
	 *
	 * Renders the debug layer toggle button
	 */
	drawDebugButton() {
		this.debugCtx.save();
		this.debugCtx.fillStyle = this.debugButton.color;
		if (this.input.isElementHovered("debugButton", "debug")) {
			this.debugCtx.fillStyle = "#ff6666";
		}
		this.debugCtx.fillRect(this.debugButton.x, this.debugButton.y, this.debugButton.width, this.debugButton.height);
		this.debugCtx.fillStyle = "#ffffff";
		this.debugCtx.font = "16px Orbitron";
		this.debugCtx.textAlign = "center";
		this.debugCtx.fillText(
			this.debugButton.text,
			this.debugButton.x + this.debugButton.width / 2,
			this.debugButton.y + this.debugButton.height / 2
		);
		this.debugCtx.restore();
	}

	/**
	 * drawDebugMessages()
	 *
	 * Renders the debug message log on the debug layer
	 */
	drawDebugMessages() {
		this.debugCtx.font = "14px monospace";
		this.debugCtx.fillStyle = "#00ff00";

		this.messages.forEach((msg, i) => {
			this.debugCtx.fillText(msg, this.padding, this.debugCanvas.height - (this.padding + i * this.lineHeight));
		});

		// Draw debug header
		this.debugCtx.fillText(`Debug Mode (F9 to toggle)`, this.padding, this.padding + 20);
	}

	/**
	 * drawStatsDisplay()
	 *
	 * Renders a stats display on the GUI layer showing click count and buttons
	 */
	drawStatsDisplay() {
		this.guiCtx.save();
		this.guiCtx.font = "20px Orbitron";

		// Calculate stats box dimensions
		const statsText = `Total Clicks: ${this.totalClicks}`;
		const buttonText = `Buttons: ${this.totalButtons}`;
		const textWidth = Math.max(this.guiCtx.measureText(statsText).width, this.guiCtx.measureText(buttonText).width);

		const padding = 15;
		const boxHeight = 70;
		const boxWidth = textWidth + padding * 2;
		const boxX = this.guiCanvas.width - boxWidth - 20;
		const boxY = 20;

		// Create a semi-transparent box
		this.guiCtx.fillStyle = "rgba(10, 10, 42, 0.85)";
		this.guiCtx.beginPath();
		this.guiCtx.roundRect(boxX, boxY, boxWidth, boxHeight, 8);
		this.guiCtx.fill();

		// Add a subtle border
		this.guiCtx.strokeStyle = "rgba(0, 240, 240, 0.3)";
		this.guiCtx.lineWidth = 2;
		this.guiCtx.stroke();

		// Draw stats text
		this.guiCtx.fillStyle = "#00f0f0";
		this.guiCtx.textAlign = "left";
		this.guiCtx.fillText(statsText, boxX + padding, boxY + 30);
		this.guiCtx.fillText(buttonText, boxX + padding, boxY + 55);

		this.guiCtx.restore();
	}
}
```

So like, the idea was to be able to tell AI like, yo, all this stuff is working great, study how the Game class works and then make a game using the system we've built here by ONLY supplying the Game class (and any other classes Game needs that aren't part of the existing system).

The key insight is: The example shows the PATTERNS for input handling and animation - use those patterns but feel free to respond to input however your game needs to.

Your purpose is to complete a TASK of creating a programming project by utilizing the classes in the Action Engine that you have no idea about, so you must follow the PATTERN of the Template.

Additonal classes which complement the Game class is ok. I think by the end of this you should feel confident that you could make ANOTHER GAME using the API available and referenced in the template.

Upon detailed inspection you can see that the template isn't just showing a working example - it's showing the required patterns for working with the EXTERNAL input, audio, and display systems. Follow these patterns first, THEN add your game mechanics on top.

Structure the game around core foundational data points and state management. Each game element should have clear, well-defined properties that serve as single sources of truth (position, velocity, state, etc.). Use consistent data structures that can be easily referenced, modified, and extended.

The codebase should be lean but complete - every variable and function should serve an immediate purpose while maintaining clean interfaces for future expansion.

Example architecture priorities:
	- Central game state object with predictable structure
	- Entity components with standardized properties
	- Collision, position, and boundary data that can be reliably referenced
	- Clear relationships between game elements (player->projectiles, enemies->drops)
	- State machines for complex behaviors

AVOID premature abstraction or speculative utility functions. Code should be minimal but robust, with each data point serving as a reliable foundation for current gameplay and future features. Write only what's needed now, but ensure what's written is solid enough to build upon later.




It theory, your TASK will be easy. Normally cumbersome game framework buildouts like input and audio and everything are handled for you. It's the game developer's dream, to just ONLY work on the game and game logic.

	- External systems handle scaling the fixed-size gameCanvas (as well as guiCanvas and debugCanvas canvases) to fit ANY display properly. 
	
	- You can expect to do anything you need to to these canvases and not experience any interference with external Action Engine systems.

	- All the inputs will be handled by the external InputManager (here refered to as `input`) which handles maintaining an input state. The Game class will just check the state of inputs for input handling through an API. Reference the template example for all input types, there is an example for each one.

	- All sounds and playback will be handled by the external SoundManager (here refered to as 'audio') wich maintains an audio library and handles playback. Reference the template API calls to this external class for creating your sounds and playing them.


I don't want you to take any design or programming logic from the demo, especially any sytlistic or design decisions. It's intended design is as a DEMO, but in reality it's purpose is to be a documented artifact to help explain how to interface with Action Engine's systems.

I want you to see the example so you can get a feel of the correct ways to interface with Action Engine, but I don't want the terrible style to like to stifle your creativity.

Instead I want to inform you of these few requirements:

	- DirUp/DLR and Action1-4 are the hardcoded inputs you have available as far as "key inputs" go, touch/mouse is supported also

	- All visuals, ui and interactable objects MUST be contained in the constructor's provided `canvas`

	- Set up the game with a fixed 800x600 internal resolution that never changes:
		- Use this fixed coordinate space as your reliable "world" size
		- Game logic always runs at this fixed size
		
	- The game will work, and be playable, from start screen to gameplay to game over

    - There will be NO PLACEHOLDER code
       - Structure all responses with clear priority order - tackle critical systems first, then build outward
       - Stay focused on completing each priority level before moving to the next.

	- The games demonstrated are in 2D, but 3D is totally possible, don't limit yourself

!!!I don't want an example, not a basic starting point, but a finished product fully polished stunning release build.!!!

I want you to work with the Action Engine and make a game.  Tell me about how much sense everything makes to you and how you understand the concept and the api calls. Tell me how you understand that the strict, but solid game design philosophy requirements elaborated here are not just for making not just games, but all software, and how you're ready to take on a project that maintains these constraints. Then ask me what game we are going to make.