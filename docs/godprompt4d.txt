User: So, I have this demo/document for a game engine I have been working on:

```
	/**
 * Welcome to the Action Engine!
 * The Action Engine simplifies game development by handling the complex setup of essential systems.
 * All vital systems are pre-initialized - input, audio, rendering, and physics - so you can focus on YOUR GAME!
 * 
 * This DEMO shows both engine requirements and example game implementation.
 * Look for "ENGINE REQUIREMENT" vs "DEMO EXAMPLE" comments to understand the difference.
 */

/** 
 * THE GAME CLASS - Engine Entry Point
 * 
 * The Game class is the heart of Action Engine and your only required class.
 * Action Engine will interact with your `Game` class
 * `Game` is NOT provided by Action Engine
 * `Game` is NOT meant to be extended
 * Action Engine cannot function without a `Game` class!
 * 
 * ENGINE PROVIDED UTILITIES:
 * - Vector2, Vector3, Matrix4 classes for math operations
 * - Three-layer canvas system for clean rendering separation
 * - Input system handling keyboard, mouse, and touch
 * - Audio system with synthesis and MIDI instrument support
 * - 3D rendering and physics systems
 */

/**
 * THE THREE-LAYER CANVAS SYSTEM
 * 
 * Action Engine uses three canvas layers for clean separation:
 * 
 * 1. gameCanvas (bottom) - Your main game content (2D or 3D)
 * 2. guiCanvas (middle) - UI elements, menus, HUD (always 2D)  
 * 3. debugCanvas (top) - Development tools, debug info (always 2D)
 * 
 * INPUT LAYER PRIORITY: debugCanvas → guiCanvas → gameCanvas
 * When you click, the input system checks layers from top to bottom.
 * If a top layer handles the click, lower layers don't receive it.
 * 
 * RENDERING: Each layer has its own context for drawing.
 * You choose 2D or 3D for gameCanvas, others are always 2D.
 */

class Game {
    /******* ENGINE REQUIREMENT: Game Class Constructor *******/
    constructor(canvases, input, audio) {
        /**
         * ENGINE REQUIREMENT: Accept these three parameters
         * 
         * canvases: Object containing the three-layer system
         *   - gameCanvas: Main game layer (you choose 2D or 3D context)
         *   - guiCanvas: UI layer (always 2D context)  
         *   - debugCanvas: Debug layer (always 2D context)
         *   - guiCtx: Pre-created 2D context for guiCanvas
         *   - debugCtx: Pre-created 2D context for debugCanvas
         * 
         * input: The input system handling all device input
         * audio: The audio system for sound creation and playback
         */

        /******* ENGINE REQUIREMENT: Store System References *******/
        this.input = input;
        this.audio = audio;

        /******* ENGINE REQUIREMENT: Store Canvas References *******/
        // Main game layer - choose your context type
        this.gameCanvas = canvases.gameCanvas;
        
        // DEMO EXAMPLE: This demo uses 3D, but you could use 2D
        this.gl = this.gameCanvas.getContext("webgl2") || this.gameCanvas.getContext("webgl");
        // Alternative for 2D games: this.gameCtx = this.gameCanvas.getContext("2d");
        
        // UI and debug layers (always 2D)
        this.guiCanvas = canvases.guiCanvas;
        this.debugCanvas = canvases.debugCanvas;
        this.guiCtx = canvases.guiCtx;     // Pre-created 2D context
        this.debugCtx = canvases.debugCtx; // Pre-created 2D context

        /******* ENGINE REQUIREMENT: Fixed Coordinate System *******/
        // Action Engine uses fixed 800x600 dimensions for consistent positioning
        // All scaling and aspect ratio handling is done automatically
        
        /******* DEMO EXAMPLE: Initialize Game-Specific Systems *******/
        // Everything below this point is DEMO IMPLEMENTATION
        // Your game will have different setup based on your needs
        this.setupGame();
        
        console.log("[Action Engine] Game initialization completed");
    }

    /******* ENGINE REQUIREMENT: Fixed Coordinate System Constants *******/
    static WIDTH = 800;
    static HEIGHT = 600;

    /******* DEMO EXAMPLE: Game-Specific Setup *******/
    setupGame() {
        /**
         * This method contains DEMO-SPECIFIC implementation.
         * Your game will have completely different setup code here.
         * This shows examples of using engine features for a specific game.
         */

        /******* DEMO: 3D Rendering Setup *******/
        // Initialize 3D renderer for this demo's 3D world
        this.renderer3D = new ActionRenderer3D(this.gameCanvas);
        this.physicsWorld = new ActionPhysicsWorld3D();

        /******* DEMO: Camera Configuration *******/
        // Setup camera for this demo's 3D world
        this.camera = new ActionCamera();
        this.camera.position = new Vector3(0, 15, -30);
        this.camera.target = new Vector3(0, 0, 0);
        this.camera.isDetached = true; // Start in free camera mode

        /******* DEMO: Game State *******/
        this.player = null; // No character spawned initially
        
        /******* DEMO: Debug Message System *******/
        // This is DEMO-SPECIFIC - not part of Action Engine
        // Shows one way to implement debug logging
        this.messages = [];
        this.maxMessages = 20;
        this.lineHeight = 20;
        this.padding = 10;
        this.showDebug = false;

        /******* DEMO: Click Tracking *******/
        // Demo-specific statistics for button interaction examples
        this.totalClicks = 0;
        this.totalButtons = 4;

        /******* DEMO: 2D Mini-Game Setup *******/
        // The demo includes a 2D game that runs on the debug layer
        // This shows Vector2 usage and 2D game techniques
        this.shipPosition = Vector2.create(Game.WIDTH / 2, Game.HEIGHT / 2);
        this.shipRotation = 0;
        this.shipVelocity = Vector2.create();
        this.shipDirection = Vector2.create(0, -1);
        this.rotationSpeed = 0.05;
        this.thrust = 0.05;
        this.friction = 0.98;

        this.ballPosition = Vector2.create(300, 300);
        this.ballVelocity = Vector2.create(2, 1);
        this.ballRadius = 20;
        this.ballRotation = 0;
        this.ballSpinSpeed = 0.03;

        /******* DEMO: Initialize Demo Components *******/
        this.lastTime = performance.now();
        this.setupDemoObjects();      // Create 3D physics objects
        this.initializeInteractiveElements(); // Setup UI buttons
        this.createGameSounds();      // Create audio examples
        
        console.log("[Demo Game] Game-specific setup completed");
    }

    /******* DEMO EXAMPLE: Physics Object Creation *******/
    setupDemoObjects() {
        // DEMO: Create basic 3D world objects to show physics system usage
        this.ground = this.createGround();
        this.box = this.createBox();
        this.sphere = this.createSphere();
        
        this.addMessage("[Game] Created basic physics objects");
    }

    /******* DEMO EXAMPLE: Debug Message System *******/
    addMessage(msg) {
        // This is DEMO-SPECIFIC debug logging, not part of Action Engine
        this.messages.unshift(`[${new Date().toLocaleTimeString()}] ${msg}`);
        if (this.messages.length > this.maxMessages) {
            this.messages.pop();
        }
    }

    /******* DEMO EXAMPLE: Physics Object Factory Methods *******/
    createBox(width = 5, height = 5, depth = 5, mass = 1, position = new Vector3(0, 15, 0)) {
        const box = new ActionPhysicsBox3D(this.physicsWorld, width, height, depth, mass, position);
        this.physicsWorld.addObject(box);
        return box;
    }

    createSphere(radius = 3, mass = 1, position = new Vector3(8, 20, 0)) {
        const sphere = new ActionPhysicsSphere3D(this.physicsWorld, radius, mass, position);
        this.physicsWorld.addObject(sphere);
        return sphere;
    }

    createGround(size = 100, position = new Vector3(0, -0.5, 0)) {
        // Create static ground using a flat box (mass = 0 means static)
        return this.createBox(size, 1, size, 0, position);
    }

    createRandomObject(position) {
        // DEMO: Random object spawning for physics demonstration
        const objectType = Math.random() > 0.5 ? 0 : 1;

        switch (objectType) {
            case 0: // Sphere
                const sphereRadius = Math.random() * 3 + 1;
                const sphereMass = Math.random() * 5 + 1;
                return this.createSphere(sphereRadius, sphereMass, position);

            case 1: // Box
                const boxWidth = Math.random() * 4 + 2;
                const boxHeight = Math.random() * 4 + 2;
                const boxDepth = Math.random() * 4 + 2;
                const boxMass = Math.random() * 5 + 1;
                return this.createBox(boxWidth, boxHeight, boxDepth, boxMass, position);
        }
    }

    /******* DEMO EXAMPLE: Character Spawning *******/
    spawnCharacter() {
        if (!this.player) {
            this.addMessage("Spawning 3D character");

            // Create character controller (connects camera to player)
            this.player = new ActionCharacter3D(this.camera, this);
            this.physicsWorld.objects.add(this.player.characterModel);

            // Position character in world
            if (this.player.characterModel && this.player.characterModel.body) {
                this.player.characterModel.body.position.set(0, 5, 0);
            }

            // Switch camera to follow character
            this.camera.isDetached = false;
            this.audio.play("spawnSound");
        }
    }

    /******* ENGINE REQUIREMENT: Update Hook *******/
    action_update(deltaTime) {
        // ENGINE REQUIREMENT: This method is called every frame by Action Engine
        this.update(deltaTime);
    }

    /******* ENGINE FEATURE: Fixed Update Hook *******/
    action_fixed_update(fixedDeltaTime) {
        // ENGINE REQUIREMENT: Called at fixed intervals for consistent physics
        // Use this for physics and time-critical updates
        
        if (!this.showDebug && this.physicsWorld) {
            this.physicsWorld.fixed_update(fixedDeltaTime);
            
            if (this.player && typeof this.player.fixed_update === 'function') {
                this.player.fixed_update(fixedDeltaTime);
            }
        }
    }

    /******* ENGINE REQUIREMENT: Draw Hook *******/
    action_draw() {
        // ENGINE REQUIREMENT: This method is called every frame for rendering
        this.draw();
    }
	
	/**
     * ENGINE FEATURE: Three-Layer Input Element System
     * 
     * Action Engine's input system works with the three canvas layers:
     * - Events flow from top to bottom: debugCanvas → guiCanvas → gameCanvas
     * - If a top layer handles input, lower layers don't receive it
     * - Register elements with bounds relative to their target canvas
     * - Coordinates are automatically translated between layers
     * 
     * REGISTRATION PATTERNS:
     * - Default layer (guiCanvas): registerElement('id', bounds)
     * - Specific layer: registerElement('id', bounds, 'debug'|'gui'|'game')
     */

    /******* DEMO EXAMPLE: Interactive UI Setup *******/
    initializeInteractiveElements() {
        /**
         * This method shows DEMO-SPECIFIC button creation and input registration.
         * Your game will have different UI elements and interaction patterns.
         * This demonstrates the input system capabilities.
         */

        /******* DEMO: Button Template *******/
        // Shared styling for consistent demo buttons
        const buttonTemplate = {
            width: 120,
            height: 40, 
            color: "#00f0f0",
            hovered: false
        };

        /******* DEMO: Create Demo Buttons *******/
        // Main centered button
        this.button1 = {
            ...buttonTemplate,
            x: (Game.WIDTH - buttonTemplate.width) / 2,
            y: (Game.HEIGHT - buttonTemplate.height) / 2,
            text: "Click Me 1"
        };

        // Additional demo buttons
        this.button2 = { ...buttonTemplate, x: 340, y: 180, text: "Click Me 2" };
        this.button3 = { ...buttonTemplate, x: 340, y: 80, text: "Click Me 3" };
        
        // Inactive button demo (shows active/inactive element system)
        this.inactiveButton = {
            ...buttonTemplate,
            x: 340, y: 480,
            text: "Inactive",
            isActive: false,
            color: "#666666"
        };

        // Character spawn button
        this.spawnButton = {
            ...buttonTemplate,
            width: 200,
            x: (Game.WIDTH - 200) / 2,
            y: Game.HEIGHT - 80,
            text: "Spawn Character"
        };

        /******* DEMO: Layer-Specific Elements *******/
        // Debug layer button (shows layer-specific registration)
        this.debugButton = {
            x: Game.WIDTH - 130, y: Game.HEIGHT - 50,
            width: 120, height: 40,
            text: "Hide GUI", color: "#ff4444",
            hovered: false, guiHidden: false
        };

        // Game layer element (shows game canvas interaction)
        this.gameElement = {
            x: 600, y: 100, width: 100, height: 100,
            text: "Stop Sounds", color: "#44ff44", hovered: false
        };

        /******* ENGINE USAGE: Input System Registration *******/
        // Register elements with input system for interaction tracking
        
        // GUI layer elements (default layer)
        this.input.registerElement("button1", {
            bounds: () => ({
                x: this.button1.x, y: this.button1.y,
                width: this.button1.width, height: this.button1.height
            })
        });

        this.input.registerElement("button2", {
            bounds: () => ({
                x: this.button2.x, y: this.button2.y,
                width: this.button2.width, height: this.button2.height
            })
        });

        this.input.registerElement("button3", {
            bounds: () => ({
                x: this.button3.x, y: this.button3.y,
                width: this.button3.width, height: this.button3.height
            })
        });

        this.input.registerElement("inactiveButton", {
            bounds: () => ({
                x: this.inactiveButton.x, y: this.inactiveButton.y,
                width: this.inactiveButton.width, height: this.inactiveButton.height
            })
        });

        this.input.registerElement("spawnButton", {
            bounds: () => ({
                x: this.spawnButton.x, y: this.spawnButton.y,
                width: this.spawnButton.width, height: this.spawnButton.height
            })
        });

        // Debug layer registration (explicit layer specification)
        this.input.registerElement("debugButton", {
            bounds: () => ({
                x: this.debugButton.x, y: this.debugButton.y,
                width: this.debugButton.width, height: this.debugButton.height
            })
        }, "debug");

        // Game layer registration (explicit layer specification)  
        this.input.registerElement("gameElement", {
            bounds: () => ({
                x: this.gameElement.x, y: this.gameElement.y,
                width: this.gameElement.width, height: this.gameElement.height
            })
        }, "game");
    }

    /******* DEMO EXAMPLE: Game Update Logic *******/
    update(deltaTime) {
        /**
         * This method contains DEMO-SPECIFIC update logic.
         * Your game will have completely different update patterns.
         * This shows examples of input handling and state management.
         */

        // Handle all key and pointer inputs
        this.handleInput();

        // Route updates based on debug overlay state
        if (this.showDebug) {
            this.update2DGame(deltaTime);  // DEMO: 2D mini-game
        } else {
            this.update3DWorld(deltaTime); // DEMO: 3D world
        }

        // Update UI interaction states
        this.updateButtonStates();
    }

    /******* DEMO EXAMPLE: 3D World Updates *******/
    update3DWorld(deltaTime) {
        // DEMO: 3D character and camera control
        if (this.player) {
            this.player.applyInput(this.input, deltaTime);
            this.player.update(deltaTime);
        } else {
            // Free camera control when no character
            if (this.camera.isDetached) {
                this.camera.handleDetachedInput(this.input, deltaTime);
            }
        }

        // DEMO: Physics object spawning
        if (this.input.isKeyJustPressed("Action3")) {
            this.addMessage("Spawning random physics object");
            const randomX = Math.random() * 40 - 20;
            const randomZ = Math.random() * 40 - 20; 
            const dropHeight = Math.random() * 10 + 20;
            const randomPos = new Vector3(randomX, dropHeight, randomZ);
            this.createRandomObject(randomPos);
        }

        // DEMO: Physics world reset
        if (this.input.isKeyJustPressed("Action2")) {
            this.addMessage("Resetting physics world");
            this.physicsWorld.reset();
            
            if (this.player) {
                this.physicsWorld.objects.add(this.player.characterModel);
                if (this.player.characterModel && this.player.characterModel.body) {
                    this.player.characterModel.body.position.set(0, 5, 0);
                }
            }
            
            this.setupDemoObjects();
        }
    }

    /******* DEMO EXAMPLE: 2D Mini-Game Updates *******/
    update2DGame(deltaTime) {
        /**
         * DEMO: 2D game that runs on debug layer when debug mode is active
         * Shows Vector2 usage and 2D game mechanics
         */

        // Ship movement controls
        if (this.input.isKeyPressed("DirUp")) {
            this.addMessage("Ship thrusting forward");
            const thrustVector = Vector2.create(this.shipDirection.x, this.shipDirection.y);
            thrustVector.scale(this.thrust);
            this.shipVelocity.add(thrustVector);
        }

        if (this.input.isKeyPressed("DirDown")) {
            this.addMessage("Ship reversing");
            const thrustVector = Vector2.create(this.shipDirection.x, this.shipDirection.y);
            thrustVector.scale(-this.thrust * 0.5);
            this.shipVelocity.add(thrustVector);
        }

        if (this.input.isKeyPressed("DirLeft")) {
            this.addMessage("Ship turning left");
            this.shipRotation -= this.rotationSpeed;
            this.shipDirection.rotate(-this.rotationSpeed);
        }

        if (this.input.isKeyPressed("DirRight")) {
            this.addMessage("Ship turning right");
            this.shipRotation += this.rotationSpeed;
            this.shipDirection.rotate(this.rotationSpeed);
        }

        // Sound demonstrations on key press
        if (this.input.isKeyJustPressed("DirUp")) this.audio.play("TrumpetCall");
        if (this.input.isKeyJustPressed("DirDown")) this.audio.play("PianoHit");
        if (this.input.isKeyJustPressed("DirLeft")) this.audio.play("MidiSynthMix");
        if (this.input.isKeyJustPressed("DirRight")) this.audio.play("SimpleSong");

        // Action button demonstrations
        if (this.input.isKeyJustPressed("Action1")) this.audio.play("jump");
        if (this.input.isKeyJustPressed("Action2")) this.audio.play("sound2");
        if (this.input.isKeyJustPressed("Action3")) this.audio.play("sound3");
        if (this.input.isKeyPressed("Action4")) this.audio.play("sound4");

        // Apply 2D physics
        this.shipPosition.add(this.shipVelocity);
        this.shipVelocity.scale(this.friction);

        // Screen wrapping
        if (this.shipPosition.x < 0) this.shipPosition.x = Game.WIDTH;
        if (this.shipPosition.x > Game.WIDTH) this.shipPosition.x = 0;
        if (this.shipPosition.y < 0) this.shipPosition.y = Game.HEIGHT;
        if (this.shipPosition.y > Game.HEIGHT) this.shipPosition.y = 0;

        // Update ball
        this.ballPosition.add(this.ballVelocity);
        this.ballRotation += this.ballSpinSpeed;

        // Ball screen wrapping
        if (this.ballPosition.x < -this.ballRadius) this.ballPosition.x = Game.WIDTH + this.ballRadius;
        if (this.ballPosition.x > Game.WIDTH + this.ballRadius) this.ballPosition.x = -this.ballRadius;
        if (this.ballPosition.y < -this.ballRadius) this.ballPosition.y = Game.HEIGHT + this.ballRadius;
        if (this.ballPosition.y > Game.HEIGHT + this.ballRadius) this.ballPosition.y = -this.ballRadius;

        // Collision detection
        const dx = this.shipPosition.x - this.ballPosition.x;
        const dy = this.shipPosition.y - this.ballPosition.y;
        const distance = Math.sqrt(dx * dx + dy * dy);

        if (distance < this.ballRadius + 20) {
            const collisionAngle = Math.atan2(dy, dx);
            const speed = Math.sqrt(this.ballVelocity.x * this.ballVelocity.x + this.ballVelocity.y * this.ballVelocity.y);
            this.ballVelocity.x = -Math.cos(collisionAngle) * speed;
            this.ballVelocity.y = -Math.sin(collisionAngle) * speed;
            this.ballVelocity.add(this.shipVelocity);
            this.audio.play("sound3");
        }
    }

    /******* ENGINE USAGE: Common Input Handling *******/
    handleInput() {
        /**
         * Shows ENGINE INPUT SYSTEM usage patterns.
         * These examples demonstrate the input API capabilities.
         */

        // Debug mode toggle (engine-level feature)
        if (this.input.isKeyJustPressed("ActionDebugToggle")) {
            this.showDebug = !this.showDebug;
            this.addMessage(this.showDebug ? "Debug mode ON - 2D game active" : "Debug mode OFF - 3D world active");
            if (!this.showDebug) {
                this.debugCtx.clearRect(0, 0, Game.WIDTH, Game.HEIGHT);
            }
        }

        // Mouse position tracking
        const pointerPos = this.input.getPointerPosition();
        if (pointerPos.x !== this.lastPointerX || pointerPos.y !== this.lastPointerY) {
            this.addMessage(`Pointer at: ${Math.round(pointerPos.x)}, ${Math.round(pointerPos.y)}`);
            this.lastPointerX = pointerPos.x;
            this.lastPointerY = pointerPos.y;
        }

        // Mouse button demonstrations
        if (this.input.isLeftMouseButtonJustPressed()) {
            this.addMessage("LEFT mouse button pressed");
        }
        if (this.input.isRightMouseButtonJustPressed()) {
            this.addMessage("RIGHT mouse button pressed");
        }
        if (this.input.isMiddleMouseButtonJustPressed()) {
            this.addMessage("MIDDLE mouse button pressed");
        }

        // UI control demonstrations
        if (this.input.isUIButtonJustPressed("soundToggle")) {
            this.addMessage("Sound button toggled");
        }
        if (this.input.isUIButtonJustPressed("fullscreenToggle")) {
            this.addMessage("Fullscreen button toggled");
        }
    }

    /******* DEMO EXAMPLE: Button State Management *******/
    updateButtonStates() {
        /**
         * DEMO-SPECIFIC button interaction handling.
         * Shows input system element interaction patterns.
         */

        // Update hover states
        this.button1.hovered = this.input.isElementHovered("button1");
        this.button2.hovered = this.input.isElementHovered("button2");
        this.button3.hovered = this.input.isElementHovered("button3");
        this.inactiveButton.hovered = this.input.isElementHovered("inactiveButton");
        this.spawnButton.hovered = this.input.isElementHovered("spawnButton");
        this.debugButton.hovered = this.input.isElementHovered("debugButton", "debug");

        // Handle button interactions
        if (this.input.isElementJustPressed("button1")) {
            const newActiveState = !this.input.isElementActive("inactiveButton");
            this.input.setElementActive("inactiveButton", "gui", newActiveState);
            this.inactiveButton.color = newActiveState ? "#00f0f0" : "#666666";
            this.addMessage(`Inactive button ${newActiveState ? "enabled" : "disabled"}`);
            this.totalClicks++;
        }

        if (this.input.isElementJustPressed("button2")) {
            this.addMessage("Button 2 pressed!");
            this.audio.play("sound5");
            this.totalClicks++;
        }

        if (this.input.isElementJustPressed("button3")) {
            this.totalClicks++;
        }

        if (this.input.isElementPressed("button3")) {
            this.addMessage("Button 3 being held");
            this.audio.play("sound6");
        }

        if (this.input.isElementJustPressed("inactiveButton") && this.input.isElementActive("inactiveButton")) {
            this.audio.play("victory");
            this.totalClicks++;
        }

        if (this.input.isElementJustPressed("gameElement", "game")) {
            this.audio.stopAllSounds();
            this.addMessage("Game element pressed! All sounds stopped.");
            this.totalClicks++;
        }

        if (this.input.isElementJustPressed("debugButton", "debug")) {
            this.debugButton.guiHidden = !this.debugButton.guiHidden;
            this.debugButton.text = this.debugButton.guiHidden ? "Show GUI" : "Hide GUI";
            this.guiCanvas.style.display = this.debugButton.guiHidden ? "none" : "block";
            this.addMessage("Debug button toggled GUI visibility");
        }

        if (this.input.isElementJustPressed("spawnButton")) {
            this.spawnCharacter();
            this.totalClicks++;
        }
    }

    /**
     * ENGINE FEATURE: Audio System
     * 
     * Action Engine provides multiple synthesis methods:
     * - Basic waveforms (sine, triangle, square)
     * - FM synthesis for rich, dynamic sounds
     * - Complex synthesis (multiple oscillators)
     * - Noise generation (white, pink, brown)
     * - Frequency sweeps for effects
     * - Full 128-instrument MIDI library
     * - SonicPi-style sequencing for complex arrangements
     * 
     * AUDIO CONTROL:
     * - Real-time parameter control
     * - Stereo panning and volume envelopes
     * - Individual sound control (play, stop, stopAll)
     */

    /******* DEMO EXAMPLE: Audio System Usage *******/
    createGameSounds() {
        /**
         * This method demonstrates AUDIO SYSTEM capabilities.
         * These are examples - your game will have different sounds.
         * Shows various synthesis methods and techniques.
         */

        /******* Basic Sound Effects *******/
        // Jump sound using frequency sweep
        this.audio.createSweepSound("jump", {
            startFreq: 220, endFreq: 880,
            type: "triangle", duration: 0.25,
            envelope: { attack: 0.05, decay: 0.1, sustain: 0.8, release: 0.1 }
        });

        // Power-up effect using multiple oscillators
        this.audio.createComplexSound("sound2", {
            frequencies: [440, 587, 880, 1174],
            types: ["triangle", "sine", "triangle", "sine"],
            mix: [0.4, 0.3, 0.2, 0.1],
            duration: 0.4,
            envelope: { attack: 0.01, decay: 0.2, sustain: 0.6, release: 0.19 }
        });

        /******* FM Synthesis Examples *******/
        this.audio.createFMSound("sound4", {
            carrierFreq: 185, modulatorFreq: 92.5,
            modulationIndex: 100, type: "sine",
            duration: 0.6,
            envelope: { attack: 0.15, decay: 0.25, sustain: 0.6, release: 0.2 }
        });

        /******* MIDI Instrument Examples *******/
        // Piano demonstration
        this.audio.createSound("PianoHit", {
            script: `
                use_bpm 120
                sample :piano, note: 60, amp: 0.5
            `,
            samples: {
                piano: { soundType: "midi", instrument: "acoustic_grand_piano", amp: 0.5 }
            }
        }, "sonicpi");

        // Trumpet call
        this.audio.createSound("TrumpetCall", {
            script: `
                use_bpm 120
                sample :trumpet, note: 67, amp: 0.4
                sleep 0.2
                sample :trumpet, note: 72, amp: 0.5
            `,
            samples: {
                trumpet: { soundType: "midi", instrument: "trumpet", amp: 0.4 }
            }
        }, "sonicpi");

        /******* Complex Musical Sequence *******/
        this.audio.createSound("SimpleSong", {
            script: `
                use_bpm 80
                define :melody do
                    sample :piano, note: 67, amp: 0.4
                    sleep 2
                    sample :piano, note: 72, amp: 0.3
                    sleep 2
                    sample :bells, note: 84, amp: 0.2
                    sleep 2
                    sample :bells, note: 79, amp: 0.2
                    sleep 2
                end
                
                8.times do
                    sample :bass, note: 48, amp: 0.4
                    sample :strings, note: 60, amp: 0.3, duration: 8
                    melody
                end
            `,
            samples: {
                piano: { soundType: "midi", instrument: "acoustic_grand_piano", amp: 0.4 },
                bells: { soundType: "midi", instrument: "tubular_bells", amp: 0.2 },
                bass: { soundType: "midi", instrument: "acoustic_bass", amp: 0.4 },
                strings: { soundType: "midi", instrument: "string_ensemble_1", amp: 0.3 }
            }
        }, "sonicpi");

        // Create additional demo sounds...
        this.createAdditionalDemoSounds();

        /******* Spawn character sound *******/
        this.audio.createSweepSound("spawnSound", {
            startFreq: 300, endFreq: 600,
            type: "triangle", duration: 0.3,
            envelope: { attack: 0.05, decay: 0.1, sustain: 0.5, release: 0.15 }
        });
    }

    createAdditionalDemoSounds() {
        // Additional demo sounds for completeness
        this.audio.createComplexSound("sound3", {
            frequencies: [220, 330, 440],
            types: ["triangle", "square", "triangle"],
            mix: [0.5, 0.2, 0.1], duration: 0.35,
            envelope: { attack: 0.08, decay: 0.15, sustain: 0.6, release: 0.12 }
        });

        this.audio.createComplexSound("sound5", {
            frequencies: [220, 330, 440, 660],
            types: ["sine", "sine", "triangle", "sine"],
            mix: [0.4, 0.3, 0.2, 0.1], duration: 0.7,
            envelope: { attack: 0.2, decay: 0.3, sustain: 0.4, release: 0.2 }
        });

        this.audio.createComplexSound("sound6", {
            frequencies: [294, 370, 440],
            types: ["sine", "triangle", "sine"],
            mix: [0.45, 0.35, 0.2], duration: 0.5,
            envelope: { attack: 0.1, decay: 0.2, sustain: 0.5, release: 0.2 }
        });

        this.audio.createComplexSound("victory", {
            frequencies: [330, 440, 550, 660, 880],
            types: ["triangle", "sine", "triangle", "sine", "triangle"],
            mix: [0.3, 0.25, 0.2, 0.15, 0.1], duration: 0.7,
            envelope: { attack: 0.1, decay: 0.25, sustain: 0.5, release: 0.3 }
        });

        // Add MIDI synth mix
        this.audio.createSound("MidiSynthMix", {
            script: `
                use_bpm 120
                sample :pad, note: 60, amp: 0.3, duration: 4
                sample :soft_synth, note: 72, amp: 0.3
                sleep 1
                sample :soft_synth, note: 76, amp: 0.25
                sleep 1
            `,
            samples: {
                pad: { soundType: "midi", instrument: "pad_3_polysynth", amp: 0.3 },
                soft_synth: { type: "sin", frequency: 440, decay: 1.5, amp: 0.3 }
            }
        }, "sonicpi");
    }
	
	/******* ENGINE REQUIREMENT: Master Drawing Method *******/
    draw() {
        /**
         * ENGINE REQUIREMENT: This method is called every frame by Action Engine.
         * 
         * The three-layer rendering system allows clean separation:
         * 1. gameCanvas - Your main game content (2D or 3D)
         * 2. guiCanvas - UI elements that overlay the game (always 2D)
         * 3. debugCanvas - Development tools and debug info (always 2D)
         * 
         * Each layer renders independently, creating a clean composition.
         * This demo shows all three layers in use.
         */

        // Render main game content (3D in this demo)
        this.draw3DScene();

        // Render UI overlay (always 2D)
        this.drawGUILayer();

        // Render debug overlay when active (always 2D)
        if (this.showDebug) {
            this.drawDebugLayer();
        }
    }

    /******* ENGINE USAGE: 3D Scene Rendering *******/
    draw3DScene() {
        /**
         * DEMO EXAMPLE: 3D world rendering using Action Engine's 3D systems.
         * Your 2D game would use gameCanvas.getContext('2d') instead.
         * 
         * Shows how to use ActionRenderer3D for clean 3D rendering without
         * dealing with WebGL complexity directly.
         */

        if (!this.gl) return;

        // Clear 3D scene with sky blue background
        this.gl.clearColor(0.529, 0.808, 0.922, 1.0); // Sky blue
        this.gl.clear(this.gl.COLOR_BUFFER_BIT | this.gl.DEPTH_BUFFER_BIT);

        // Use Action Engine's 3D renderer for simplified rendering
        this.renderer3D.render({
            renderableObjects: Array.from(this.physicsWorld.objects),
            camera: this.camera
        });

        /**
         * ENGINE FEATURE: ActionRenderer3D
         * 
         * The 3D renderer handles:
         * - Automatic shader management
         * - Camera matrix calculations
         * - Object transformation and rendering
         * - Lighting setup
         * - Depth testing and culling
         * 
         * You just provide renderable objects and a camera.
         * All WebGL complexity is abstracted away.
         */
    }

    /******* ENGINE USAGE: GUI Layer Rendering *******/
    drawGUILayer() {
        /**
         * ENGINE USAGE: GUI layer is always 2D for crisp UI rendering.
         * 
         * The guiCanvas provides:
         * - Pixel-perfect UI rendering
         * - Automatic scaling handling
         * - Clean separation from game content
         * - Consistent coordinate system (800x600)
         * 
         * This layer is perfect for:
         * - Buttons and menus
         * - HUD elements
         * - Score displays
         * - Game statistics
         * - Modal dialogs
         */

        // Clear the GUI layer
        this.guiCtx.clearRect(0, 0, this.guiCanvas.width, this.guiCanvas.height);

        /******* DEMO: Render Interactive Buttons *******/
        // Draw all demo buttons using consistent styling
        [this.button1, this.button2, this.button3, this.inactiveButton, this.spawnButton].forEach(button => {
            this.drawButton(button);
        });

        /******* DEMO: Render Game Statistics *******/
        this.drawStatsDisplay();

        /******* DEMO: Render Instructions Based on Game State *******/
        if (!this.showDebug) {
            this.draw3DInstructions();
        }
    }

    /******* DEMO EXAMPLE: Button Rendering Utility *******/
    drawButton(button) {
        /**
         * DEMO-SPECIFIC button rendering with hover effects.
         * Your game will have different UI styling and components.
         * 
         * Shows 2D canvas techniques:
         * - Rounded rectangles for modern UI look
         * - Hover state color changes
         * - Centered text rendering
         * - Consistent visual styling
         */

        this.guiCtx.save();

        // Background with hover effect
        this.guiCtx.fillStyle = button.hovered ? "#00b0b0" : button.color;
        this.guiCtx.strokeStyle = "#ffffff";
        this.guiCtx.lineWidth = 2;

        // Draw rounded rectangle button
        this.guiCtx.beginPath();
        this.guiCtx.roundRect(button.x, button.y, button.width, button.height, 8);
        this.guiCtx.fill();
        this.guiCtx.stroke();

        // Draw centered button text
        this.guiCtx.fillStyle = "#ffffff";
        this.guiCtx.font = "20px Orbitron";
        this.guiCtx.textAlign = "center";
        this.guiCtx.textBaseline = "middle";
        this.guiCtx.fillText(
            button.text,
            button.x + button.width / 2,
            button.y + button.height / 2
        );

        this.guiCtx.restore();

        /**
         * UI DESIGN PATTERNS:
         * 
         * BUTTON STATES:
         * - Normal: Base color
         * - Hovered: Lighter/darker variation
         * - Active: Different color during press
         * - Disabled: Grayed out appearance
         * 
         * ACCESSIBILITY:
         * - Clear visual feedback for interactions
         * - Sufficient color contrast
         * - Readable font sizes
         * - Consistent spacing and alignment
         */
    }

    /******* DEMO EXAMPLE: Statistics Display *******/
    drawStatsDisplay() {
        /**
         * DEMO-SPECIFIC stats panel showing click tracking.
         * Demonstrates advanced 2D canvas techniques for UI panels.
         */

        this.guiCtx.save();
        this.guiCtx.font = "20px Orbitron";

        // Calculate panel dimensions based on content
        const statsText = `Total Clicks: ${this.totalClicks}`;
        const buttonText = `Buttons: ${this.totalButtons}`;
        const textWidth = Math.max(
            this.guiCtx.measureText(statsText).width,
            this.guiCtx.measureText(buttonText).width
        );

        const padding = 15;
        const boxHeight = 70;
        const boxWidth = textWidth + padding * 2;
        const boxX = this.guiCanvas.width - boxWidth - 20;
        const boxY = 20;

        // Semi-transparent background panel
        this.guiCtx.fillStyle = "rgba(10, 10, 42, 0.85)";
        this.guiCtx.beginPath();
        this.guiCtx.roundRect(boxX, boxY, boxWidth, boxHeight, 8);
        this.guiCtx.fill();

        // Subtle border for depth
        this.guiCtx.strokeStyle = "rgba(0, 240, 240, 0.3)";
        this.guiCtx.lineWidth = 2;
        this.guiCtx.stroke();

        // Render statistics text
        this.guiCtx.fillStyle = "#00f0f0";
        this.guiCtx.textAlign = "left";
        this.guiCtx.fillText(statsText, boxX + padding, boxY + 30);
        this.guiCtx.fillText(buttonText, boxX + padding, boxY + 55);

        this.guiCtx.restore();

        /**
         * UI PANEL DESIGN PRINCIPLES:
         * 
         * VISUAL HIERARCHY:
         * - Use color and size to indicate importance
         * - Group related information together
         * - Provide clear visual boundaries
         * 
         * TRANSPARENCY:
         * - Semi-transparent backgrounds allow game visibility
         * - Use appropriate alpha values (0.7-0.9 typically)
         * - Ensure text remains readable over any background
         * 
         * POSITIONING:
         * - Consider screen edges and corners for UI placement
         * - Leave breathing room around elements
         * - Account for different screen sizes and aspect ratios
         */
    }

    /******* DEMO EXAMPLE: 3D World Instructions *******/
    draw3DInstructions() {
        /**
         * DEMO-SPECIFIC instruction display for 3D mode.
         * Shows dynamic text rendering based on game state.
         */

        this.guiCtx.font = "16px Arial";
        this.guiCtx.fillStyle = "white";
        this.guiCtx.textAlign = "left";
        this.guiCtx.textBaseline = "top";

        let yOffset = 10;
        const lineHeight = 20;

        // Title
        this.guiCtx.fillText("3D World Demo with Action Engine", 10, yOffset);
        yOffset += lineHeight * 2;

        // Context-sensitive instructions
        if (this.player) {
            this.guiCtx.fillText("Character Controls:", 10, yOffset);
            yOffset += lineHeight;
            this.guiCtx.fillText("• Action1: Jump (when on ground)", 10, yOffset);
            yOffset += lineHeight;
            this.guiCtx.fillText("• Arrow Keys: Move character", 10, yOffset);
            yOffset += lineHeight;
        } else {
            this.guiCtx.fillText("Free Camera Controls:", 10, yOffset);
            yOffset += lineHeight;
            this.guiCtx.fillText("• Arrow Keys: Move camera", 10, yOffset);
            yOffset += lineHeight;
            this.guiCtx.fillText("• Click 'Spawn Character' to create player", 10, yOffset);
            yOffset += lineHeight;
        }

        // Universal controls
        this.guiCtx.fillText("• F9: Toggle debug overlay (2D mini-game)", 10, yOffset);
        yOffset += lineHeight;
        this.guiCtx.fillText("• Action2: Reset physics objects", 10, yOffset);
        yOffset += lineHeight;
        this.guiCtx.fillText("• Action3: Spawn random object", 10, yOffset);
        yOffset += lineHeight;

        // Dynamic status information
        this.guiCtx.fillText(`Objects in world: ${this.physicsWorld.objects.size}`, 10, yOffset);
        yOffset += lineHeight;

        // Character debug information
        if (this.player && this.player.debugInfo) {
            const debugInfo = this.player.debugInfo;
            yOffset += lineHeight;
            this.guiCtx.fillText("Character Debug Info:", 10, yOffset);
            yOffset += lineHeight;
            this.guiCtx.fillText(`• State: ${debugInfo.state.current}`, 10, yOffset);
            yOffset += lineHeight;
            this.guiCtx.fillText(
                `• Position: (${debugInfo.physics.position.x.toFixed(2)}, ${debugInfo.physics.position.y.toFixed(2)}, ${debugInfo.physics.position.z.toFixed(2)})`,
                10, yOffset
            );
            yOffset += lineHeight;
            this.guiCtx.fillText(
                `• Velocity: (${debugInfo.physics.velocity.x.toFixed(2)}, ${debugInfo.physics.velocity.y.toFixed(2)}, ${debugInfo.physics.velocity.z.toFixed(2)})`,
                10, yOffset
            );
        }

        /**
         * DYNAMIC UI PRINCIPLES:
         * 
         * CONTEXTUAL INFORMATION:
         * - Show relevant controls based on current state
         * - Hide irrelevant information to reduce clutter
         * - Update information in real-time
         * 
         * PROGRESSIVE DISCLOSURE:
         * - Start with essential information
         * - Add detail progressively
         * - Allow users to access more detail when needed
         * 
         * REAL-TIME FEEDBACK:
         * - Show current state information
         * - Update values continuously
         * - Format numbers appropriately (decimals, units)
         */
    }

    /******* ENGINE USAGE: Debug Layer Rendering *******/
    drawDebugLayer() {
        /**
         * ENGINE USAGE: Debug layer for development tools and debug visualization.
         * 
         * The debugCanvas provides:
         * - Top-most rendering layer
         * - Development and debugging tools
         * - Optional visibility (F9 toggle)
         * - Full access to canvas for custom debug rendering
         * 
         * This demo uses it for:
         * - Debug message logging
         * - 2D mini-game when debug mode is active
         * - Debug-specific UI controls
         */

        // Clear debug layer
        this.debugCtx.clearRect(0, 0, this.debugCanvas.width, this.debugCanvas.height);

        // Semi-transparent background to indicate debug mode
        this.debugCtx.fillStyle = "rgba(0, 0, 0, 0.7)";
        this.debugCtx.fillRect(0, 0, this.debugCanvas.width, this.debugCanvas.height);

        // Render debug-specific content
        this.draw2DGame();           // DEMO: Mini-game on debug layer
        this.drawDebugButton();      // Debug layer UI element
        this.drawDebugMessages();    // Debug message log
    }

    /******* DEMO EXAMPLE: 2D Mini-Game Rendering *******/
    draw2DGame() {
        /**
         * DEMO-SPECIFIC 2D game that runs on the debug layer.
         * Shows Vector2 usage and 2D canvas rendering techniques.
         * 
         * This demonstrates:
         * - Using the debug layer for alternative gameplay
         * - 2D sprite-like rendering
         * - Physics visualization
         * - Game state rendering
         */

        const ctx = this.debugCtx;

        // Space-like background (semi-transparent to show debug layer)
        ctx.fillStyle = "rgba(0, 0, 51, 0.5)";
        ctx.fillRect(0, 0, this.debugCanvas.width, this.debugCanvas.height);

        /******* Render Spaceship *******/
        ctx.save();
        ctx.translate(this.shipPosition.x, this.shipPosition.y);
        ctx.rotate(this.shipRotation);

        // Draw triangular ship
        ctx.beginPath();
        ctx.moveTo(0, -20);   // nose
        ctx.lineTo(-15, 20);  // left wing
        ctx.lineTo(15, 20);   // right wing
        ctx.closePath();

        ctx.strokeStyle = "#00ff00";
        ctx.lineWidth = 2;
        ctx.stroke();

        // Draw thrust effect when moving forward
        if (this.input.isKeyPressed("DirUp") && this.showDebug) {
            ctx.beginPath();
            ctx.moveTo(-8, 20);
            ctx.lineTo(0, 30);
            ctx.lineTo(8, 20);
            ctx.strokeStyle = "#ff0000";
            ctx.lineWidth = 3;
            ctx.stroke();
        }

        ctx.restore();

        /******* Render Soccer Ball with 3D Effect *******/
        ctx.save();
        ctx.translate(this.ballPosition.x, this.ballPosition.y);
        ctx.rotate(this.ballRotation);

        // Create radial gradient for 3D sphere effect
        const gradient = ctx.createRadialGradient(-5, -5, 1, -5, -5, this.ballRadius * 2);
        gradient.addColorStop(0, "#ffffff");   // Highlight
        gradient.addColorStop(0.7, "#cccccc"); // Mid-tone
        gradient.addColorStop(1, "#888888");   // Shadow

        // Draw main ball sphere
        ctx.beginPath();
        ctx.arc(0, 0, this.ballRadius, 0, Math.PI * 2);
        ctx.fillStyle = gradient;
        ctx.fill();

        // Draw pentagon pattern for soccer ball design
        const segments = 5;
        const angleStep = (Math.PI * 2) / segments;
        ctx.globalAlpha = 0.3;
        
        for (let i = 0; i < segments; i++) {
            const angle = i * angleStep;
            
            ctx.beginPath();
            ctx.moveTo(0, 0);
            ctx.lineTo(
                Math.cos(angle) * this.ballRadius,
                Math.sin(angle) * this.ballRadius
            );
            ctx.lineTo(
                Math.cos(angle + angleStep) * this.ballRadius,
                Math.sin(angle + angleStep) * this.ballRadius
            );
            ctx.closePath();
            
            ctx.fillStyle = i % 2 === 0 ? "#000000" : "#ffffff";
            ctx.fill();
        }

        // Add highlight for 3D effect
        ctx.globalAlpha = 0.6;
        ctx.beginPath();
        ctx.arc(-5, -5, this.ballRadius / 3, 0, Math.PI * 2);
        ctx.fillStyle = "rgba(255, 255, 255, 0.8)";
        ctx.fill();

        ctx.restore();

        /******* 2D Game Information Display *******/
        ctx.globalAlpha = 1.0;
        ctx.fillStyle = "#00ff00";
        ctx.font = "14px monospace";
        ctx.textAlign = "left";
        
        ctx.fillText("Debug Mode Active - 2D Mini-Game Running", this.padding, this.padding + 50);
        ctx.fillText("Use Arrow Keys to control the ship", this.padding, this.padding + 70);
        ctx.fillText("Try to hit the ball with your ship!", this.padding, this.padding + 90);
        ctx.fillText("Collision detection and physics active", this.padding, this.padding + 110);

        /**
         * 2D RENDERING TECHNIQUES DEMONSTRATED:
         * 
         * TRANSFORMS:
         * - save()/restore() for isolated transformations
         * - translate() for positioning
         * - rotate() for rotation effects
         * 
         * GRADIENTS:
         * - Radial gradients for 3D sphere effects
         * - Multiple color stops for smooth transitions
         * - Proper gradient positioning for lighting effects
         * 
         * ALPHA BLENDING:
         * - globalAlpha for transparency effects
         * - rgba() colors for per-element transparency
         * - Layered rendering for complex visuals
         * 
         * PATH DRAWING:
         * - beginPath()/closePath() for shape definition
         * - moveTo()/lineTo() for custom shapes
         * - arc() for circles and curved elements
         */
    }

    /******* DEMO EXAMPLE: Debug Button Rendering *******/
    drawDebugButton() {
        /**
         * DEMO-SPECIFIC debug layer button.
         * Shows layer-specific UI element rendering.
         */

        this.debugCtx.save();

        // Button background with hover effect
        this.debugCtx.fillStyle = this.debugButton.hovered ? "#ff6666" : this.debugButton.color;
        this.debugCtx.fillRect(
            this.debugButton.x, this.debugButton.y,
            this.debugButton.width, this.debugButton.height
        );

        // Button border
        this.debugCtx.strokeStyle = "#ffffff";
        this.debugCtx.lineWidth = 2;
        this.debugCtx.strokeRect(
            this.debugButton.x, this.debugButton.y,
            this.debugButton.width, this.debugButton.height
        );

        // Button text
        this.debugCtx.fillStyle = "#ffffff";
        this.debugCtx.font = "16px Orbitron";
        this.debugCtx.textAlign = "center";
        this.debugCtx.textBaseline = "middle";
        this.debugCtx.fillText(
            this.debugButton.text,
            this.debugButton.x + this.debugButton.width / 2,
            this.debugButton.y + this.debugButton.height / 2
        );

        this.debugCtx.restore();
    }

    /******* DEMO EXAMPLE: Debug Message Log *******/
    drawDebugMessages() {
        /**
         * DEMO-SPECIFIC debug message display system.
         * Shows scrolling text log implementation.
         */

        this.debugCtx.font = "14px monospace";
        this.debugCtx.fillStyle = "#00ff00";
        this.debugCtx.textAlign = "left";
        this.debugCtx.textBaseline = "top";

        // Draw messages from bottom up (newest at bottom)
        this.messages.forEach((msg, i) => {
            const y = this.debugCanvas.height - (this.padding + (i + 1) * this.lineHeight);
            this.debugCtx.fillText(msg, this.padding, y);
        });

        // Draw debug header
        this.debugCtx.fillStyle = "#ffff00";
        this.debugCtx.font = "16px monospace";
        this.debugCtx.fillText("Debug Mode (F9 to toggle)", this.padding, this.padding + 20);
        
        // Draw message log header
        this.debugCtx.fillStyle = "#00ff00";
        this.debugCtx.font = "14px monospace";
        this.debugCtx.fillText("Message Log:", this.padding, this.debugCanvas.height - (this.padding + this.messages.length * this.lineHeight) - 25);
    }
}
```

So like, the idea was to be able to tell AI like, yo, all this stuff is working great, study how the Game class works and then make a game using the system we've built here by ONLY supplying the Game class (and any other classes Game needs that aren't part of the existing system).

The key insight is: The example shows the PATTERNS for input handling and animation - use those patterns but feel free to respond to input however your game needs to.

Your purpose is to complete a TASK of creating a programming project by utilizing the classes in the Action Engine that you have no idea about, so you must follow the PATTERN of the Template.

Additonal classes which complement the Game class is ok. I think by the end of this you should feel confident that you could make ANOTHER GAME using the API available and referenced in the template.

Upon detailed inspection you can see that the template isn't just showing a working example - it's showing the required patterns for working with the EXTERNAL input, audio, and display systems. Follow these patterns first, THEN add your game mechanics on top.

Structure the game around core foundational data points and state management. Each game element should have clear, well-defined properties that serve as single sources of truth (position, velocity, state, etc.). Use consistent data structures that can be easily referenced, modified, and extended.

The codebase should be lean but complete - every variable and function should serve an immediate purpose while maintaining clean interfaces for future expansion.

Example architecture priorities:
	- Central game state object with predictable structure
	- Entity components with standardized properties
	- Collision, position, and boundary data that can be reliably referenced
	- Clear relationships between game elements (player->projectiles, enemies->drops)
	- State machines for complex behaviors

AVOID premature abstraction or speculative utility functions. Code should be minimal but robust, with each data point serving as a reliable foundation for current gameplay and future features. Write only what's needed now, but ensure what's written is solid enough to build upon later.




It theory, your TASK will be easy. Normally cumbersome game framework buildouts like input and audio and everything are handled for you. It's the game developer's dream, to just ONLY work on the game and game logic.

	- External systems handle scaling the fixed-size gameCanvas (as well as guiCanvas and debugCanvas canvases) to fit ANY display properly. 
	
	- You can expect to do anything you need to to these canvases and not experience any interference with external Action Engine systems.

	- All the inputs will be handled by the external InputManager (here refered to as `input`) which handles maintaining an input state. The Game class will just check the state of inputs for input handling through an API. Reference the template example for all input types, there is an example for each one.

	- All sounds and playback will be handled by the external SoundManager (here refered to as 'audio') wich maintains an audio library and handles playback. Reference the template API calls to this external class for creating your sounds and playing them.


I don't want you to take any design or programming logic from the demo, especially any sytlistic or design decisions. It's intended design is as a DEMO, but in reality it's purpose is to be a documented artifact to help explain how to interface with Action Engine's systems.

I want you to see the example so you can get a feel of the correct ways to interface with Action Engine, but I don't want the terrible style to like to stifle your creativity.

Instead I want to inform you of these few requirements:

	- DirUp/DLR and Action1-4 are the hardcoded inputs you have available as far as "key inputs" go, touch/mouse is supported also

	- All visuals, ui and interactable objects MUST be contained in the constructor's provided `canvas`

	- Set up the game with a fixed 800x600 internal resolution that never changes:
		- Use this fixed coordinate space as your reliable "world" size
		- Game logic always runs at this fixed size
		
	- The game will work, and be playable, from start screen to gameplay to game over

    - There will be NO PLACEHOLDER code
       - Structure all responses with clear priority order - tackle critical systems first, then build outward
       - Stay focused on completing each priority level before moving to the next.

	- The games demonstrated are in 2D, but 3D is totally possible, don't limit yourself

!!!I don't want an example, not a basic starting point, but a finished product fully polished stunning release build.!!!

I want you to work with the Action Engine and make a game.  Tell me about how much sense everything makes to you and how you understand the concept and the api calls. Tell me how you understand that the strict, but solid game design philosophy requirements elaborated here are not just for making not just games, but all software, and how you're ready to take on a project that maintains these constraints. Then ask me what game we are going to make.