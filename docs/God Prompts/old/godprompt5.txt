User: So, I have this demo/document for a game engine I have been working on:

```JavaScript
class Game {
    constructor(canvases, input, audio) {
        this.input = input;
        this.audio = audio;
        
        this.canvas = canvases.gameCanvas;       
        this.guiCanvas = canvases.guiCanvas;     
        this.debugCanvas = canvases.debugCanvas; 

        if (Game.DEMO_RENDER_MODE === '3d') {
            this.gl = this.canvas.getContext('webgl');
            if (!this.gl) {
                throw new Error('WebGL not supported - try setting DEMO_RENDER_MODE to "2d"');
            }
            this.initGL();
            this.rotationX = 0;
            this.rotationY = 0;
            this.orbitRadius = 4.0;  
            this.orbitSpeed = 0.02;  
            this.orbitAngle = 0;     
            this.position = Vector3.create(0, 0, -6); 
        } else {
            this.ctx = this.canvas.getContext('2d');
        }

        this.guiCtx = canvases.guiCtx;           
        this.debugCtx = canvases.debugCtx; 

        this.messages = [];      
        this.maxMessages = 20;   
        this.lineHeight = 20;    
        this.padding = 10;       
        this.showDebug = false;  

        this.totalClicks = 0;    
        this.totalButtons = 3;   

        this.shipPosition = Vector2.create(Game.WIDTH / 2, Game.HEIGHT / 2); 
        this.shipRotation = 0;  
        this.shipVelocity = Vector2.create();
        this.shipDirection = Vector2.create(0, -1); 
        this.rotationSpeed = 0.05;
        this.thrust = 0.05;
        this.friction = 0.98;

        this.ballPosition = Vector2.create(300, 300);
        this.ballVelocity = Vector2.create(2, 1);
        this.ballRadius = 20;
        this.ballRotation = 0;
        this.ballSpinSpeed = 0.03;
		
		this.initializeInteractiveElements();
		this.createGameSounds();
    }

    static WIDTH = 800;
    static HEIGHT = 600;
   
    static DEMO_RENDER_MODE = '3d';  

    initGL() {
       const vsSource = `
           attribute vec4 aVertexPosition;
           attribute vec2 aTextureCoord;
           
           uniform mat4 uModelViewMatrix;
           uniform mat4 uProjectionMatrix;
           
           varying highp vec2 vTextureCoord;
           
           void main(void) {
               gl_Position = uProjectionMatrix * uModelViewMatrix * aVertexPosition;
               vTextureCoord = aTextureCoord;
           }
       `;

       const fsSource = `
           varying highp vec2 vTextureCoord;
           
           uniform sampler2D uSampler;
           
           void main(void) {
               gl_FragColor = texture2D(uSampler, vTextureCoord);
           }
       `;

       const vertexShader = this.loadShader(this.gl.VERTEX_SHADER, vsSource);
       const fragmentShader = this.loadShader(this.gl.FRAGMENT_SHADER, fsSource);

       this.shaderProgram = this.gl.createProgram();
       this.gl.attachShader(this.shaderProgram, vertexShader);
       this.gl.attachShader(this.shaderProgram, fragmentShader);
       this.gl.linkProgram(this.shaderProgram);

       if (!this.gl.getProgramParameter(this.shaderProgram, this.gl.LINK_STATUS)) {
           throw new Error('Shader program failed to initialize');
       }

       this.programInfo = {
           program: this.shaderProgram,
           attribLocations: {
               vertexPosition: this.gl.getAttribLocation(this.shaderProgram, 'aVertexPosition'),
               textureCoord: this.gl.getAttribLocation(this.shaderProgram, 'aTextureCoord'),
           },
           uniformLocations: {
               projectionMatrix: this.gl.getUniformLocation(this.shaderProgram, 'uProjectionMatrix'),
               modelViewMatrix: this.gl.getUniformLocation(this.shaderProgram, 'uModelViewMatrix'),
               uSampler: this.gl.getUniformLocation(this.shaderProgram, 'uSampler'),
           },
       };

       const positions = [
           -1.0, -1.0,  1.0,
            1.0, -1.0,  1.0,
            1.0,  1.0,  1.0,
           -1.0,  1.0,  1.0,
           
           -1.0, -1.0, -1.0,
           -1.0,  1.0, -1.0,
            1.0,  1.0, -1.0,
            1.0, -1.0, -1.0,
           
           -1.0,  1.0, -1.0,
           -1.0,  1.0,  1.0,
            1.0,  1.0,  1.0,
            1.0,  1.0, -1.0,
           
           -1.0, -1.0, -1.0,
            1.0, -1.0, -1.0,
            1.0, -1.0,  1.0,
           -1.0, -1.0,  1.0,
           
            1.0, -1.0, -1.0,
            1.0,  1.0, -1.0,
            1.0,  1.0,  1.0,
            1.0, -1.0,  1.0,
           
           -1.0, -1.0, -1.0,
           -1.0, -1.0,  1.0,
           -1.0,  1.0,  1.0,
           -1.0,  1.0, -1.0,
       ];

       const textureCoordinates = [
           0.0,  0.0,
           1.0,  0.0,
           1.0,  1.0,
           0.0,  1.0,
           0.0,  0.0,
           1.0,  0.0,
           1.0,  1.0,
           0.0,  1.0,
           0.0,  0.0,
           1.0,  0.0,
           1.0,  1.0,
           0.0,  1.0,
           0.0,  0.0,
           1.0,  0.0,
           1.0,  1.0,
           0.0,  1.0,
           0.0,  0.0,
           1.0,  0.0,
           1.0,  1.0,
           0.0,  1.0,
           0.0,  0.0,
           1.0,  0.0,
           1.0,  1.0,
           0.0,  1.0,
       ];

       const indices = [
           0,  1,  2,    0,  2,  3,
           4,  5,  6,    4,  6,  7,
           8,  9,  10,   8,  10, 11,
           12, 13, 14,   12, 14, 15,
           16, 17, 18,   16, 18, 19,
           20, 21, 22,   20, 22, 23,
       ];

       this.positionBuffer = this.gl.createBuffer();
       this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.positionBuffer);
       this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(positions), this.gl.STATIC_DRAW);

       this.textureCoordBuffer = this.gl.createBuffer();
       this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.textureCoordBuffer);
       this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(textureCoordinates), this.gl.STATIC_DRAW);

       this.indexBuffer = this.gl.createBuffer();
       this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);
       this.gl.bufferData(this.gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indices), this.gl.STATIC_DRAW);

       this.texture = this.gl.createTexture();
       this.gl.bindTexture(this.gl.TEXTURE_2D, this.texture);

       const pixels = new Uint8Array([
           255, 255, 255, 255,  0,   0,   0,   255,
           0,   0,   0,   255,  255, 255, 255, 255,
       ]);
       const level = 0;
       const internalFormat = this.gl.RGBA;
       const width = 2;
       const height = 2;
       const border = 0;
       const srcFormat = this.gl.RGBA;
       const srcType = this.gl.UNSIGNED_BYTE;
       
       this.gl.texImage2D(this.gl.TEXTURE_2D, level, internalFormat,
                         width, height, border, srcFormat, srcType,
                         pixels);

       this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MIN_FILTER, this.gl.NEAREST);
       this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MAG_FILTER, this.gl.NEAREST);
   }

   loadShader(type, source) {
       const shader = this.gl.createShader(type);
       this.gl.shaderSource(shader, source);
       this.gl.compileShader(shader);

       if (!this.gl.getShaderParameter(shader, this.gl.COMPILE_STATUS)) {
           this.gl.deleteShader(shader);
           throw new Error('Shader failed to compile');
       }

       return shader;
   }

   initializeInteractiveElements() {
       const buttonTemplate = {
           width: 120,          
           height: 40,          
           color: '#00f0f0',    
           hovered: false       
       };

       this.button1 = {
           ...buttonTemplate, 
           x: (Game.WIDTH - buttonTemplate.width) / 2,         
           y: (Game.HEIGHT - buttonTemplate.height) / 2,       
           text: 'Click Me 1' 
       };

       this.button2 = {
           ...buttonTemplate,
           x: 340,              
           y: 180,              
           text: 'Click Me 2'   
       };

       this.button3 = {
           ...buttonTemplate,
           x: 340,
           y: 80,
           text: 'Click Me 3'
       };

       this.inactiveButton = {
            ...buttonTemplate,                    
            x: 340,                             
            y: 480,                             
            text: 'Inactive',                    
            isInactive: false,                    
            color: '#666666'                     
       };

       this.input.registerElement('button1', {
           bounds: () => ({                    
               x: this.button1.x,         
               y: this.button1.y,         
               width: this.button1.width, 
               height: this.button1.height 
           })
       });

       this.input.registerElement('button2', {
           bounds: () => ({
               x: this.button2.x,
               y: this.button2.y,
               width: this.button2.width,
               height: this.button2.height
           })
       });

       this.input.registerElement('button3', {
           bounds: () => ({
               x: this.button3.x,
               y: this.button3.y,
               width: this.button3.width,
               height: this.button3.height
           })
       });

       this.input.registerElement('inactiveButton', {
            bounds: () => ({
                x: this.inactiveButton.x,
                y: this.inactiveButton.y,
                width: this.inactiveButton.width,
                height: this.inactiveButton.height
            })
       });

       this.debugButton = {
           x: Game.WIDTH - 130,                
           y: Game.HEIGHT - 50,                
           width: 120,
           height: 40,
           text: 'Hide GUI',                   
           color: '#ff4444',                   
           hovered: false,
           guiHidden: false                    
       };

       this.gameElement = {
           x: 600,
           y: 100,
           width: 100,
           height: 100,
           text: 'Stop Sounds', 
           color: '#44ff44',
           hovered: false
       };

       this.input.registerElement('debugButton', {
           bounds: () => ({
               x: this.debugButton.x,
               y: this.debugButton.y,
               width: this.debugButton.width,
               height: this.debugButton.height
           })
       }, 'debug');  

       this.input.registerElement('gameElement', {
           bounds: () => ({
               x: this.gameElement.x,
               y: this.gameElement.y,
               width: this.gameElement.width,
               height: this.gameElement.height
           })
       }, 'game');  
   }

   createGameSounds() {
       this.audio.createFMSound('fmSound', {
           carrierFreq: 440,      
           modulatorFreq: 100,    
           modulationIndex: 100,  
           type: 'sine',          
           duration: 0.5,
           envelope: {
               attack: 0.1,
               decay: 0.2,
               sustain: 0.6,
               release: 0.2
           }
       });

       this.audio.createComplexSound('complexSound', {
           frequencies: [440, 880, 1320],  
           types: ['sine', 'triangle', 'square'],  
           mix: [0.5, 0.3, 0.2],  
           duration: 0.8,
           envelope: {
               attack: 0.1,
               decay: 0.2,
               sustain: 0.5,
               release: 0.3
           }
       });

       this.audio.createNoiseSound('noiseSound', {
           noiseType: 'white',  
           duration: 0.5,
           envelope: {
               attack: 0.05,
               decay: 0.1,
               sustain: 0.7,
               release: 0.2
           },
           filterOptions: {
               frequency: 1000,  
               Q: 1,            
               type: 'lowpass'  
           }
       });

       this.audio.createSweepSound('sweepSound', {
           startFreq: 200,   
           endFreq: 800,     
           type: 'triangle', 
           duration: 0.6,
           envelope: {
               attack: 0.1,
               decay: 0.2,
               sustain: 0.4,
               release: 0.2
           }
       });
		
       this.audio.createSweepSound('jump', {
           startFreq: 220,         
           endFreq: 880,          
           type: 'triangle',       
           duration: 0.25,         
           envelope: {             
               attack: 0.05,       
               decay: 0.1,         
               sustain: 0.8,       
               release: 0.1         
           }
       });

       this.audio.createComplexSound('sound2', {
           frequencies: [440, 587, 880, 1174],    
           types: ['triangle', 'sine', 'triangle', 'sine'],  
           mix: [0.4, 0.3, 0.2, 0.1],            
           duration: 0.4,
           envelope: {
               attack: 0.01,   
               decay: 0.2,
               sustain: 0.6,
               release: 0.19
           }
       });

       this.audio.createComplexSound('sound3', {
           frequencies: [220, 330, 440],          
           types: ['triangle', 'square', 'triangle'],
           mix: [0.5, 0.2, 0.1],
           duration: 0.35,
           envelope: {
               attack: 0.08,
               decay: 0.15,
               sustain: 0.6,
               release: 0.12
           }
       });

       this.audio.createFMSound('sound4', {
           carrierFreq: 185,
           modulatorFreq: 92.5,
           modulationIndex: 100,
           type: 'sine',
           duration: 0.6,
           envelope: {
               attack: 0.15,
               decay: 0.25,
               sustain: 0.6,
               release: 0.2
           }
       });

       this.audio.createComplexSound('sound5', {
           frequencies: [220, 330, 440, 660],
           types: ['sine', 'sine', 'triangle', 'sine'],
           mix: [0.4, 0.3, 0.2, 0.1],
           duration: 0.7,
           envelope: {
               attack: 0.2,
               decay: 0.3,
               sustain: 0.4,
               release: 0.2
           }
       });

       this.audio.createComplexSound('sound6', {
           frequencies: [294, 370, 440],
           types: ['sine', 'triangle', 'sine'],
           mix: [0.45, 0.35, 0.2],
           duration: 0.5,
           envelope: {
               attack: 0.1,
               decay: 0.2,
               sustain: 0.5,
               release: 0.2
           }
       });

       this.audio.createComplexSound('victory', {
           frequencies: [330, 440, 550, 660, 880],
           types: ['triangle', 'sine', 'triangle', 'sine', 'triangle'],
           mix: [0.3, 0.25, 0.2, 0.15, 0.1],
           duration: 0.7,
           envelope: {
               attack: 0.1,
               decay: 0.25,
               sustain: 0.5,
               release: 0.3
           }
       });

       this.audio.createSound('MidiSynthMix', {
           script: `
               use_bpm 120
               sample :pad, note: 60, amp: 0.3, duration: 4
               sample :soft_synth, note: 72, amp: 0.3
               sleep 1
               sample :soft_synth, note: 76, amp: 0.25
               sleep 1
           `,
           samples: {
               'pad': {
                   soundType: 'midi',
                   instrument: 'pad_3_polysynth',    
                   amp: 0.3
               },
               'soft_synth': {
                   type: 'sin',                      
                   frequency: 440,
                   decay: 1.5,
                   amp: 0.3
               }
           }
       }, 'sonicpi');

       this.audio.createSound('PianoHit', {
           script: `
               use_bpm 120
               sample :piano, note: 60, amp: 0.5
           `,
           samples: {
               'piano': {
                   soundType: 'midi',
                   instrument: 'acoustic_grand_piano',  
                   amp: 0.5
               }
           }
       }, 'sonicpi');

       this.audio.createSound('TrumpetCall', {
           script: `
               use_bpm 120
               sample :trumpet, note: 67, amp: 0.4
               sleep 0.2
               sample :trumpet, note: 72, amp: 0.5
           `,
           samples: {
               'trumpet': {
                   soundType: 'midi',
                   instrument: 'trumpet',             
                   amp: 0.4
               }
           }
       });

       this.audio.createSound('SimpleSong', {
           script: `
               use_bpm 80
               define :melody do
                   sample :piano, note: 67, amp: 0.4
                   sleep 2
                   sample :piano, note: 72, amp: 0.3
                   sleep 2
                   sample :bells, note: 84, amp: 0.2
                   sleep 2
                   sample :bells, note: 79, amp: 0.2
                   sleep 2
               end
               8.times do
                   sample :bass, note: 48, amp: 0.4
                   sample :strings, note: 60, amp: 0.3, duration: 8
                   melody
               end
           `,
           samples: {
               'piano': {
                   soundType: 'midi',
                   instrument: 'acoustic_grand_piano',  
                   amp: 0.4
               },
               'bells': {
                   soundType: 'midi',
                   instrument: 'tubular_bells',       
                   amp: 0.2
               },
               'bass': {
                   soundType: 'midi',
                   instrument: 'acoustic_bass',       
                   amp: 0.4
               },
               'strings': {
                   soundType: 'midi',
                   instrument: 'string_ensemble_1',   
                   amp: 0.3
               }
           }
       }, 'sonicpi');
   }
   addMessage(msg) {
       this.messages.unshift(`[${new Date().toLocaleTimeString()}] ${msg}`);
       if (this.messages.length > this.maxMessages) {
           this.messages.pop();
       }
   }

   update() {
       if (this.input.isKeyPressed('DirUp')) {
           this.addMessage('DirUp IS PRESSED');
           this.rotationX -= 0.04; 
           const thrustVector = Vector2.create(this.shipDirection.x, this.shipDirection.y);
           thrustVector.scale(this.thrust);
           this.shipVelocity.add(thrustVector); 
       }
       if (this.input.isKeyPressed('DirDown')) {
           this.addMessage('DirDown IS PRESSED');
           this.rotationX += 0.04; 
           const thrustVector = Vector2.create(this.shipDirection.x, this.shipDirection.y);
           thrustVector.scale(-this.thrust * 0.5);  
           this.shipVelocity.add(thrustVector);  
       }
       if (this.input.isKeyPressed('DirLeft')) {
           this.addMessage('DirLeft IS PRESSED');
           this.rotationY -= 0.04; 
           this.shipRotation -= this.rotationSpeed;
           this.shipDirection.rotate(-this.rotationSpeed); 
       }
       if (this.input.isKeyPressed('DirRight')) {
           this.addMessage('DirRight IS PRESSED');
           this.rotationY += 0.04; 
           this.shipRotation += this.rotationSpeed;
           this.shipDirection.rotate(this.rotationSpeed); 
       }

       if (this.input.isKeyJustPressed('DirUp')) {
           this.addMessage('DirUp JUST pressed');
           this.audio.play('TrumpetCall'); 
       }
       if (this.input.isKeyJustPressed('DirDown')) {
           this.addMessage('DirDown JUST pressed');
           this.audio.play('PianoHit');
       }	    
       if (this.input.isKeyJustPressed('DirLeft')) {
           this.addMessage('DirLeft JUST pressed');
           this.audio.play('MidiSynthMix');
       }	    
       if (this.input.isKeyJustPressed('DirRight')) {
           this.addMessage('DirRight JUST pressed');
           this.audio.play('SimpleSong');
       }	    
       
       if (this.input.isKeyJustPressed('Action1')) {   
           this.addMessage('Button 1 JUST pressed'); 
           this.audio.play('jump');
       }
       if (this.input.isKeyJustPressed('Action2')) {           
		  this.addMessage('Button 2 JUST pressed');  
		  this.audio.play('sound2');
	   }
	   if (this.input.isKeyJustPressed('Action3')) {           
		   this.addMessage('Button 3 JUST pressed');
		   this.audio.play('sound3');
	   }
	   
       if (this.input.isKeyPressed('Action4')) {               
		   this.addMessage('Button 4 IS PRESSED'); 
		   this.audio.play('sound4');              
	   }

       if (this.input.isKeyJustPressed('ActionDebugToggle')) { 
		   this.showDebug = !this.showDebug;                      
		   if (!this.showDebug) {                                 
			   this.debugCtx.clearRect(0, 0, Game.WIDTH, Game.HEIGHT);  
		   }
	   }

	   const pointerPos = this.input.getPointerPosition();      
	   if (pointerPos.x !== this.lastPointerX || pointerPos.y !== this.lastPointerY) {  
		   this.addMessage(`Pointer at: ${Math.round(pointerPos.x)}, ${Math.round(pointerPos.y)}`);  
		   this.lastPointerX = pointerPos.x;                    
		   this.lastPointerY = pointerPos.y;                    
	   }
	   
	   if (this.input.isPointerDown()) {
		   this.addMessage('Pointer IS PRESSED'); 
	   }
	   
	   if (this.input.isPointerJustDown()) {
		   this.addMessage('Pointer JUST pressed'); 
	   }

	   const mousePos = this.input.getPointerPosition();
	   const isInBounds = this.input.isPointInBounds(  
		   mousePos.x,
		   mousePos.y,
		   {
			   x: this.button1.x,
			   y: this.button1.y,
			   width: this.button1.width,
			   height: this.button1.height
		   }
	   );
	   
	   if (isInBounds !== this.lastInBounds) {
		   this.addMessage(`Pointer ${isInBounds ? 'entered' : 'left'} button bounds`);  
		   this.lastInBounds = isInBounds;
	   }

	   if (this.input.isUIButtonPressed('soundToggle')) { 
		   this.addMessage('Sound button pressed');
	   }
	   
	   if (this.input.isUIButtonPressed('fullscreenToggle')) { 
		   this.addMessage('Fullscreen button pressed');
	   }
	   if (this.input.isUIButtonJustPressed('controlsToggle')) { 
		   this.addMessage('Controls button pressed');
	   }
	   
	   if (this.input.isUIButtonJustPressed('pauseButton')) { 
		   this.addMessage('Pause button just pressed');
	   }
	   
	   if (this.input.isElementJustPressed('button1')) {
			const newActiveState = !this.input.isElementActive('inactiveButton');
			this.input.state.elements.gui.get('inactiveButton').isActive = newActiveState;  
			this.inactiveButton.color = newActiveState ? '#00f0f0' : '#666666';  
			this.addMessage(`Inactive button ${newActiveState ? 'enabled' : 'disabled'}`); 
			this.totalClicks++; 
	   }
	   if (this.input.isElementJustPressed('button2')) {         
		   this.addMessage('Button 2 was just pressed!');        
		   this.audio.play('sound5');                           
		   this.totalClicks++; 
	   }
	   
	   if (this.input.isElementJustPressed('button3')) {
		   this.totalClicks++;
	   }
	   
	   if (this.input.isElementPressed('button3')) {
		   this.addMessage('Button 3 is being held down'); 
		   this.audio.play('sound6');
	   }

	   this.button1.hovered = this.input.isElementHovered('button1');  
	   this.button2.hovered = this.input.isElementHovered('button2');         
	   this.button3.hovered = this.input.isElementHovered('button3');         

	   if (this.input.isElementJustHovered('button1')) {     
		   this.addMessage('Button JUST hovered');              
	   }

	   if (this.input.isElementPressed('inactiveButton')) {  
		   if (this.input.isElementActive('inactiveButton')) {
				this.addMessage('Clicking an active button!');
			} else {
				this.addMessage('Button is inactive - click Button 1 to activate it!');
			}
	   }

	   if (this.input.isElementJustPressed('inactiveButton') && this.input.isElementActive('inactiveButton')) { 
		   this.audio.play('victory');
		   this.totalClicks++;
	   }
	   
	   if (this.input.isElementJustPressed('gameElement', 'game')) {
		   this.audio.stopAllSounds();
		   this.addMessage('gameCanvas element pressed! All sounds stopped.');
		   this.totalClicks++; 
	   }
	   
	   if (this.input.isElementJustPressed('debugButton', 'debug')) {
		   this.debugButton.guiHidden = !this.debugButton.guiHidden;
		   this.debugButton.text = this.debugButton.guiHidden ? 'Show GUI' : 'Hide GUI';
		   this.guiCanvas.style.display = this.debugButton.guiHidden ? 'none' : 'block';  
		   this.addMessage('Debug button toggled GUI visibility');
	   }

	   if (this.button1.hovered && this.input.isPointerDown()) { 
		   this.addMessage('Special check works too!');
	   }

	   if (Game.DEMO_RENDER_MODE === '3d') {
		   this.orbitAngle += this.orbitSpeed;
		
		   this.position.x = Math.cos(this.orbitAngle) * this.orbitRadius;
		   this.position.z = Math.sin(this.orbitAngle) * this.orbitRadius - 6;
		
		   this.rotationX += 0.01;
		   this.rotationY += 0.01;
	   } else {
		   
		   this.shipPosition.add(this.shipVelocity);
		   this.shipVelocity.scale(this.friction);

		   if (this.shipPosition.x < 0) this.shipPosition.x = Game.WIDTH;
		   if (this.shipPosition.x > Game.WIDTH) this.shipPosition.x = 0;
		   if (this.shipPosition.y < 0) this.shipPosition.y = Game.HEIGHT;
		   if (this.shipPosition.y > Game.HEIGHT) this.shipPosition.y = 0;

		   this.ballPosition.add(this.ballVelocity);
		   this.ballRotation += this.ballSpinSpeed;

		   if (this.ballPosition.x < -this.ballRadius) this.ballPosition.x = Game.WIDTH + this.ballRadius;
		   if (this.ballPosition.x > Game.WIDTH + this.ballRadius) this.ballPosition.x = -this.ballRadius;
		   if (this.ballPosition.y < -this.ballRadius) this.ballPosition.y = Game.HEIGHT + this.ballRadius;
		   if (this.ballPosition.y > Game.HEIGHT + this.ballRadius) this.ballPosition.y = -this.ballRadius;

		   const dx = this.shipPosition.x - this.ballPosition.x;
		   const dy = this.shipPosition.y - this.ballPosition.y;
		   const distance = Math.sqrt(dx * dx + dy * dy);

		   if (distance < this.ballRadius + 20) { 
				const collisionAngle = Math.atan2(dy, dx);
				const speed = Math.sqrt(this.ballVelocity.x * this.ballVelocity.x + 
									  this.ballVelocity.y * this.ballVelocity.y);
				this.ballVelocity.x = -Math.cos(collisionAngle) * speed;
				this.ballVelocity.y = -Math.sin(collisionAngle) * speed;
				this.ballVelocity.add(this.shipVelocity);
				this.audio.play('sound3');
			}
	   }
	}

	drawButton(button) {
		this.guiCtx.save();

		this.guiCtx.fillStyle = button.hovered ? '#00b0b0' : button.color;
		this.guiCtx.strokeStyle = '#ffffff';
		this.guiCtx.lineWidth = 2;

		this.guiCtx.beginPath();
		this.guiCtx.roundRect(
			button.x,
			button.y,
			button.width,
			button.height,
			8
		);
		this.guiCtx.fill();
		this.guiCtx.stroke();

		this.guiCtx.fillStyle = '#ffffff';
		this.guiCtx.font = '20px Orbitron';
		this.guiCtx.textAlign = 'center';
		this.guiCtx.textBaseline = 'middle';
		this.guiCtx.fillText(
			button.text,
			button.x + button.width/2,
			button.y + button.height/2
		);

		this.guiCtx.restore();
	}


	drawCube() {
		this.gl.clearColor(0.0, 0.0, 0.0, 1.0);
		this.gl.clearDepth(1.0);
		this.gl.enable(this.gl.DEPTH_TEST);
		this.gl.depthFunc(this.gl.LEQUAL);

		this.gl.clear(this.gl.COLOR_BUFFER_BIT | this.gl.DEPTH_BUFFER_BIT);

		const fieldOfView = 45 * Math.PI / 180;
		const aspect = this.gl.canvas.clientWidth / this.gl.canvas.clientHeight;
		const zNear = 0.1;
		const zFar = 100.0;
		const projectionMatrix = Matrix4.create();

		Matrix4.perspective(projectionMatrix,
						fieldOfView,
						aspect,
						zNear,
						zFar);

		const modelViewMatrix = Matrix4.create();

		Matrix4.translate(modelViewMatrix,
					   modelViewMatrix,
					   [-0.0, 0.0, -6.0]);

		Matrix4.rotate(modelViewMatrix,
					modelViewMatrix,
					this.rotationX,
					[1, 0, 0]);

		Matrix4.rotate(modelViewMatrix, 
					modelViewMatrix,
					this.rotationY,
					[0, 1, 0]);

       this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.positionBuffer);
       this.gl.vertexAttribPointer(
           this.programInfo.attribLocations.vertexPosition,
           3,
           this.gl.FLOAT,
           false,
           0,
           0);
       this.gl.enableVertexAttribArray(this.programInfo.attribLocations.vertexPosition);

       this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.textureCoordBuffer);
       this.gl.vertexAttribPointer(
           this.programInfo.attribLocations.textureCoord,
           2,
           this.gl.FLOAT,
           false,
           0,
           0);
       this.gl.enableVertexAttribArray(this.programInfo.attribLocations.textureCoord);

       this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);

       this.gl.useProgram(this.programInfo.program);

       this.gl.uniformMatrix4fv(
           this.programInfo.uniformLocations.projectionMatrix,
           false,
           projectionMatrix);
       this.gl.uniformMatrix4fv(
           this.programInfo.uniformLocations.modelViewMatrix,
           false,
           modelViewMatrix);

       this.gl.activeTexture(this.gl.TEXTURE0);
       this.gl.bindTexture(this.gl.TEXTURE_2D, this.texture);
       this.gl.uniform1i(this.programInfo.uniformLocations.uSampler, 0);

       this.gl.drawElements(this.gl.TRIANGLES, 36, this.gl.UNSIGNED_SHORT, 0);
   }

	draw() {
		if (Game.DEMO_RENDER_MODE === '3d') {
			this.drawScene3D();
		} else {
			this.drawScene2D();
		}

		this.drawGUILayer();
		
		if (this.showDebug) {
			this.drawDebugLayer();
		}
	}
	
	drawScene3D() {
		this.gl.clearColor(0.0, 0.0, 0.0, 1.0);
		this.gl.clearDepth(1.0);
		this.gl.enable(this.gl.DEPTH_TEST);
		this.gl.depthFunc(this.gl.LEQUAL);
		this.gl.clear(this.gl.COLOR_BUFFER_BIT | this.gl.DEPTH_BUFFER_BIT);

		const fieldOfView = 45 * Math.PI / 180;
		const aspect = this.gl.canvas.clientWidth / this.gl.canvas.clientHeight;
		const zNear = 0.1;
		const zFar = 100.0;
		const projectionMatrix = Matrix4.create();

		Matrix4.perspective(projectionMatrix,
						fieldOfView,
						aspect,
						zNear,
						zFar);

		const modelViewMatrix = Matrix4.create();
		Matrix4.translate(modelViewMatrix, modelViewMatrix, 
		[this.position.x, this.position.y, this.position.z]);
		Matrix4.rotate(modelViewMatrix, modelViewMatrix, this.rotationX, [1, 0, 0]);
		Matrix4.rotate(modelViewMatrix, modelViewMatrix, this.rotationY, [0, 1, 0]);

       this.bindBuffersForCube();
		
       this.gl.useProgram(this.programInfo.program);
       this.setMatrixUniforms(projectionMatrix, modelViewMatrix);
		
       this.gl.drawElements(this.gl.TRIANGLES, 36, this.gl.UNSIGNED_SHORT, 0);
   }

	drawScene2D() {
		this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
		
		this.ctx.fillStyle = '#000033';
		this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

		this.ctx.save();
		this.ctx.translate(this.shipPosition.x, this.shipPosition.y);
		this.ctx.rotate(this.shipRotation);
		
		this.ctx.beginPath();
		this.ctx.moveTo(0, -20);  
		this.ctx.lineTo(-15, 20); 
		this.ctx.lineTo(15, 20);  
		this.ctx.closePath();
		
		this.ctx.strokeStyle = '#00ff00';
		this.ctx.lineWidth = 2;
		this.ctx.stroke();
		
		if (this.input.isKeyPressed('DirUp')) {
			this.ctx.beginPath();
			this.ctx.moveTo(-8, 20);
			this.ctx.lineTo(0, 30);
			this.ctx.lineTo(8, 20);
			this.ctx.strokeStyle = '#ff0000';
			this.ctx.stroke();
		}
		
		this.ctx.restore();
		this.ctx.save();
		this.ctx.translate(this.ballPosition.x, this.ballPosition.y);
		this.ctx.rotate(this.ballRotation);

		const gradient = this.ctx.createRadialGradient(
			-5, -5, 1,
			-5, -5, this.ballRadius * 2
		);
		gradient.addColorStop(0, '#ffffff');
		gradient.addColorStop(1, '#cccccc');

		this.ctx.beginPath();
		this.ctx.arc(0, 0, this.ballRadius, 0, Math.PI * 2);
		this.ctx.fillStyle = gradient;
		this.ctx.fill();

		const segments = 5;
		const angleStep = (Math.PI * 2) / segments;
		for (let i = 0; i < segments; i++) {
			const angle = i * angleStep;
			
			this.ctx.beginPath();
			this.ctx.moveTo(0, 0);
			this.ctx.lineTo(
				Math.cos(angle) * this.ballRadius,
				Math.sin(angle) * this.ballRadius
			);
			this.ctx.lineTo(
				Math.cos(angle + angleStep) * this.ballRadius,
				Math.sin(angle + angleStep) * this.ballRadius
			);
			this.ctx.closePath();
			this.ctx.fillStyle = i % 2 === 0 ? '#000000' : '#ffffff';
			this.ctx.globalAlpha = 0.3;
			this.ctx.fill();
		}

		this.ctx.beginPath();
		this.ctx.arc(-5, -5, this.ballRadius/3, 0, Math.PI * 2);
		this.ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
		this.ctx.fill();

		this.ctx.restore();
		
		this.ctx.save();
		this.drawGameElement2D();
		this.ctx.restore();
	}

	drawGameElement2D() {
		this.ctx.fillStyle = this.input.isElementHovered('gameElement', 'game') 
			? '#66ff66' 
			: this.gameElement.color;
			
		this.ctx.fillRect(
			this.gameElement.x,
			this.gameElement.y,
			this.gameElement.width,
			this.gameElement.height
		);
		
		this.ctx.fillStyle = '#000000';
		this.ctx.font = '16px Orbitron';
		this.ctx.textAlign = 'center';
		this.ctx.fillText(
			this.gameElement.text,
			this.gameElement.x + this.gameElement.width/2,
			this.gameElement.y + this.gameElement.height/2
		);
	}

	drawGUILayer() {
		this.guiCtx.clearRect(0, 0, this.guiCanvas.width, this.guiCanvas.height);
		
		[this.button1, this.button2, this.button3, this.inactiveButton].forEach(button => {
			this.drawButton(button);
		});
		
		this.drawStatsDisplay();
	}

	drawDebugLayer() {
		this.debugCtx.clearRect(0, 0, this.debugCanvas.width, this.debugCanvas.height);
		
		this.drawDebugButton();
		
		this.drawDebugMessages();
	}
	
	bindBuffersForCube() {
		this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.positionBuffer);
		this.gl.vertexAttribPointer(
			this.programInfo.attribLocations.vertexPosition,
			3,        
			this.gl.FLOAT,
			false,    
			0,        
			0         
		);
		this.gl.enableVertexAttribArray(this.programInfo.attribLocations.vertexPosition);

		this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.textureCoordBuffer);
		this.gl.vertexAttribPointer(
			this.programInfo.attribLocations.textureCoord,
			2,        
			this.gl.FLOAT,
			false,    
			0,        
			0         
		);
		this.gl.enableVertexAttribArray(this.programInfo.attribLocations.textureCoord);

		this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);
	}

	setMatrixUniforms(projectionMatrix, modelViewMatrix) {
		this.gl.uniformMatrix4fv(
			this.programInfo.uniformLocations.projectionMatrix,
			false,
			projectionMatrix
		);
		this.gl.uniformMatrix4fv(
			this.programInfo.uniformLocations.modelViewMatrix,
			false,
			modelViewMatrix);

		this.gl.activeTexture(this.gl.TEXTURE0);
		this.gl.bindTexture(this.gl.TEXTURE_2D, this.texture);
		this.gl.uniform1i(this.programInfo.uniformLocations.uSampler, 0);
	}

	drawStatsDisplay() {
		this.guiCtx.save();
		this.guiCtx.font = '20px Orbitron';
		
		const statsText = `Total Clicks: ${this.totalClicks}`;
		const buttonText = `Buttons: ${this.totalButtons}`;
		const textWidth = Math.max(
			this.guiCtx.measureText(statsText).width,
			this.guiCtx.measureText(buttonText).width
		);
		
		const padding = 15;
		const boxHeight = 70;
		const boxWidth = textWidth + (padding * 2);
		const boxX = this.guiCanvas.width - boxWidth - 20;
		const boxY = 20;

		this.guiCtx.fillStyle = 'rgba(10, 10, 42, 0.85)';
		this.guiCtx.beginPath();
		this.guiCtx.roundRect(boxX, boxY, boxWidth, boxHeight, 8);
		this.guiCtx.fill();

		this.guiCtx.strokeStyle = 'rgba(0, 240, 240, 0.3)';
		this.guiCtx.lineWidth = 2;
		this.guiCtx.stroke();

		this.guiCtx.fillStyle = '#00f0f0';
		this.guiCtx.textAlign = 'left';
		this.guiCtx.fillText(statsText, boxX + padding, boxY + 30);
		this.guiCtx.fillText(buttonText, boxX + padding, boxY + 55);

		this.guiCtx.restore();
	}

	drawDebugButton() {
		this.debugCtx.save();
		this.debugCtx.fillStyle = this.debugButton.color;
		if (this.input.isElementHovered('debugButton', 'debug')) {
			this.debugCtx.fillStyle = '#ff6666';
		}
		this.debugCtx.fillRect(
			this.debugButton.x,
			this.debugButton.y,
			this.debugButton.width,
			this.debugButton.height
		);
		this.debugCtx.fillStyle = '#ffffff';
		this.debugCtx.font = '16px Orbitron';
		this.debugCtx.textAlign = 'center';
		this.debugCtx.fillText(
			this.debugButton.text,
			this.debugButton.x + this.debugButton.width/2,
			this.debugButton.y + this.debugButton.height/2
		);
		this.debugCtx.restore();
	}

	drawDebugMessages() {
		this.debugCtx.font = '14px monospace';
		this.debugCtx.fillStyle = '#00ff00';
		
		this.messages.forEach((msg, i) => {
			this.debugCtx.fillText(
				msg, 
				this.padding, 
				this.debugCanvas.height - (this.padding + i * this.lineHeight)
			);
		});

		this.debugCtx.fillText(
			`Debug Mode (F9 to toggle)`, 
			this.padding, 
			this.padding + 20
		);
	}
	
   loop() {
       this.update();
       this.draw();
       requestAnimationFrame(() => this.loop());
   }
}


window.Game = Game;
```

So like, the idea was to be able to tell AI like, yo, all this stuff is working great, study how the Game class works and then make a game using the system we've built here by ONLY supplying the Game class (and any other classes Game needs that aren't part of the existing system).

The key insight is: The example shows the PATTERNS for input handling and animation - use those patterns but feel free to respond to input however your game needs to.

Your purpose is to complete a TASK of creating a programming project by utilizing the classes in the Action Engine that you have no idea about, so you must follow the PATTERN of the Template.

Additonal classes which complement the Game class is ok. I think by the end of this you should feel confident that you could make ANOTHER GAME using the API available and referenced in the template.

Upon detailed inspection you can see that the template isn't just showing a working example - it's showing the required patterns for working with the EXTERNAL input, audio, and display systems. Follow these patterns first, THEN add your game mechanics on top.

Structure the game around core foundational data points and state management. Each game element should have clear, well-defined properties that serve as single sources of truth (position, velocity, state, etc.). Use consistent data structures that can be easily referenced, modified, and extended.

The codebase should be lean but complete - every variable and function should serve an immediate purpose while maintaining clean interfaces for future expansion.

Example architecture priorities:
	- Central game state object with predictable structure
	- Entity components with standardized properties
	- Collision, position, and boundary data that can be reliably referenced
	- Clear relationships between game elements (player->projectiles, enemies->drops)
	- State machines for complex behaviors

AVOID premature abstraction or speculative utility functions. Code should be minimal but robust, with each data point serving as a reliable foundation for current gameplay and future features. Write only what's needed now, but ensure what's written is solid enough to build upon later.




It theory, your TASK will be easy. Normally cumbersome game framework buildouts like input and audio and everything are handled for you. It's the game developer's dream, to just ONLY work on the game and game logic.

	- External systems handle scaling the fixed-size gameCanvas (as well as guiCanvas and debugCanvas canvases) to fit ANY display properly. 
	
	- You can expect to do anything you need to to these canvases and not experience any interference with external Action Engine systems.

	- All the inputs will be handled by the external InputManager (here refered to as `input`) which handles maintaining an input state. The Game class will just check the state of inputs for input handling through an API. Reference the template example for all input types, there is an example for each one.

	- All sounds and playback will be handled by the external SoundManager (here refered to as 'audio') wich maintains an audio library and handles playback. Reference the template API calls to this external class for creating your sounds and playing them.


I don't want you to take any design or programming logic from the demo, especially any sytlistic or design decisions. It's intended design is as a DEMO, but in reality it's purpose is to be a documented artifact to help explain how to interface with Action Engine's systems.

I want you to see the example so you can get a feel of the correct ways to interface with Action Engine, but I don't want the terrible style to like to stifle your creativity.

Instead I want to inform you of these few requirements:

	- DirUp/DLR and Action1-4 are the hardcoded inputs you have available as far as "key inputs" go, touch/mouse is supported also

	- All visuals, ui and interactable objects MUST be contained in the constructor's provided `canvas`

	- Set up the game with a fixed 800x600 internal resolution that never changes:
		- Use this fixed coordinate space as your reliable "world" size
		- Game logic always runs at this fixed size
		
	- The game will work, and be playable, from start screen to gameplay to game over

    - There will be NO PLACEHOLDER code
       - Structure all responses with clear priority order - tackle critical systems first, then build outward
       - Stay focused on completing each priority level before moving to the next.

	- The games demonstrated are in 2D, but 3D is totally possible, don't limit yourself

!!!I don't want an example, not a basic starting point, but a finished product fully polished stunning release build.!!!

I want you to work with the Action Engine and make a game.  Tell me about how much sense everything makes to you and how you understand the concept and the api calls. Tell me how you understand that the strict, but solid game design philosophy requirements elaborated here are not just for making not just games, but all software, and how you're ready to take on a project that maintains these constraints.