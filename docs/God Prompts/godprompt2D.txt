User: Your TASK is to create a NEW GAME using ActionEngineJS which is a PURE JAVASCRIPT game engine framework.

Your TASK will be easy. Normally cumbersome game framework buildouts like input and audio and canvas management are handled for you. It's the game developer's dream, to ONLY work on the game visuals and game logic.

	- All visuals, ui and interactable objects MUST be contained in the provided `canvases`.
	
	- All the inputs will be handled by the external InputManager (here refered to as `input`) which handles maintaining an input state.
	
		- Both key and pointer input types are managed entirely abstractly, there should be no setup for mapping keys, the input api already has this handled.

	- All sounds and playback will be handled by the external SoundManager (here refered to as 'audio') which handles audio registration and playback.

I want to inform you of these few requirements for your TASK:

	- DirLeft/DirRight/DirUp/DirDown and Action1-4 are the hardcoded inputs you have available as far as "key inputs" go.
	- Something like `isKeyJustPressed("spacebar") will NOT work, because the keys are hardcoded in an abstract way.
	- Touch and mouse support is also handled through ActionEngine's input system.

	- The ActionEngine library handles scaling the fixed-size gameCanvas (as well as guiCanvas and debugCanvas canvases) to fit ANY display properly.
	- The game will be designed with a fixed 800x600 internal resolution that remains constant.
	- Use this fixed coordinate space as your reliable "screen" size to POSITION game elements ABSOLUTELY!
		
	- From start-screen to gameplay to game over your game will be COMPLETE, READY TO RELEASE and be a polished WORK OF ART. 

I'd like to show you some documentation for the ActionEngine library we are going to work with. Take a look and read through this carefully:

```actionengineintro
/******* ActionEngineJS *******
 * Welcome to ActionEngineJS, a pure JavaScript game framework!
 * ActionEngine simplifies the game development process by abstracting away the complexities of setting up and managing common "video game" software components. These vital systems can be tedious to implement, and really take the fun out of game development.
 * All essential systems are already initialized by Action Engine, including input, audio, and other background systems to allow developers to bypass several frustrating hurdles associated with creating and maintaining these neccesary (but boring) software mechanisms.
 * This allows the developer to focus on one thing: THE GAME! With the messy stuff out of the way, we can get right to the fun part!
 * All systems are well documented and heavily explained so there's no guesswork. By the end of this reading, you'll be a game making pro.
 * So let's dive in for a quick run down of the available features and start creating a masterpiece!
 */
```

Your TASK is to provide a `Game` class script. The `Game` class is REQUIRED:

```actionenginegameclassdocumentation
/******* The Game Class *******
 * The Game class is the heart of the Action Engine and serves as the entry point for your game.
 * Action Engine aims to let developers work in a way where their only domain is the Game class.
 * It is the ONLY required class, but any classes that will become intertwined with Game are welcome. Speaking of dependencies..
 * Like many popular game engines, ActionEngine supplies three fully featured mathematic classes to assist with common video game operations.
 * There are 3 engine-provided math classes that the developer can depend on. `Vector2` `Vector3` and `Matrix4`. These are fully-featured, though not fully demonstrated.
 * Along with input and audio, these are the ONLY additonal classes that fall within the developer's expected available API playground.
 * There will still need to be some heavy lifting with any other classes, logic, or math that needs to be handled on a game by game basis.
 * When the Game class is constructed, ActionEngine will pass necessary information like rendering canvases and references to the input and audio systems.
 * The developer can easily integrate with and control these systems without worrying about configuration or maintenance, and just focus on the game logic (and rendering).
 **/

/******* Fixed Coordinate System *******
* Internally, the Action Engine uses an 800x600 canvas using fixed dimensions.
* This allows for the developer to be worry free about resolution scaling or any of the headaches that come
* with viewports, different screen sizes, canvas scaling, aspect ratio, and the like. Forget about it!
* Action Engine uses a fixed 4:3 aspect ratio and handles all window resizing and other internal "screen"
* handling, leaving the developer a simple way to manage positioning that is straight forward.
*******/

/******* ActionEngine Systems *******
* ActionEngine requires the Game constructor to accept the following parameters:
*
* `canvases`: An object with three properties - gameCanvas, guiCanvas, and debugCanvas
*
* These are the three layers that make up the Action Engine canvas rendering system
* The canvases are automatically created and managed in the background, no need to setup your screen or anything related to window sizes or anything, it's all handled
* This system allows for easy and clear separation of UI elements and actual game content, which is often a headache especially when prototyping and needing to come back to add additional layers
* The guiCanvas and debugCanvas are set by the engine to be 2d contexts, to always give developers an option for 2d overlays
* The guiCanvas is an optional layer that is by default hidden, but can be toggled with the (ActionDebugToggle) key (defaulted to f9) allowing for the developer to have a clear and separated canvas for debug related info
* This separation allows for the developer to choose whether they want a 2d or 3d game with 2d overlays, there is plenty of room for everything
*
* `input`: The input system of the Action Engine
*
* This system seamlessly handles keyboard, mouse, and touch input in the background
* It provides an automatic and intuitive way for developers to detect input from a variety ofstandard input devices
* This allows the developer to worry less about what key does what or how the UI is handled, or the hassles of trying to implement addtional input device support, it's already done!
* To interface with the input system, Action Engine has a simple to use API which we will be showcased here in this DEMO.
*
* `audio`: The audio system of the Action Engine
*
* Sound really AMPS up a game's presentation!
* Action Engine handles sound generation and playback with comprehensive volume control, callback support, and repeat functionality built right in.
* The audio system provides individual sound volume control, automatic stacking prevention, sound completion callbacks, and flexible repeat options.
* Sound creation is very flexible, with midi instrument sample support for high quality sounds, so you don't need to search around on any sketchy sites for questionably royalty free .wav files
* The developer can get creative with the synth sampling and other sound types through an easy to use API, which will be demonstrated throughout this demo
* All that with full control over every aspect of audio playback? That's the power of Action Engine!
**/
```

These concepts can be more clearly observed by checking out the demos that ActionEngine provides, starting with an "Asteroids" game which showcases the input and canvas layering system:

```asteroidsdemo
/**
 * ActionEngine Input System Educational Demo
 * 
 * Welcome to the ActionEngine Input System demonstration! This asteroids game serves as a
 * comprehensive showcase of ActionEngine's sophisticated input handling capabilities.
 * 
 * ActionEngine simplifies game development by abstracting away input complexity while
 * providing powerful features like three-layer input priority, element registration,
 * and comprehensive mouse/keyboard support. This demo shows you how to use every
 * input feature ActionEngine provides.
 * 
 * THE THREE-LAYER INPUT SYSTEM:
 * ActionEngine uses a sophisticated three-layer input system that prevents UI conflicts:
 * 
 * DEBUG LAYER (Top Priority) -> GUI LAYER (Medium Priority) -> GAME LAYER (Low Priority)
 * 
 * When input events occur, they cascade through these layers. If an upper layer handles
 * the event (like clicking a debug button), lower layers won't receive it. This prevents
 * background elements from catching input meant for UI controls.
 */
 
/******* GAME CONFIGURATION CONSTANTS *******/
const ASTEROIDS = {
    // ActionEngine requires these exact dimensions
    WIDTH: 800,
    HEIGHT: 600,
    
    // Game physics
    PHYSICS: {
        SHIP_THRUST: 250,
        SHIP_MAX_SPEED: 300,
        SHIP_ROTATION_SPEED: 4.5,
        SHIP_FRICTION: 0.97,
        BULLET_SPEED: 400,
        BULLET_LIFETIME: 1.8,
        ASTEROID_MIN_SPEED: 20,
        ASTEROID_MAX_SPEED: 80
    },
    
    // Visual configuration
    VISUAL: {
        SHIP_SIZE: 10,
        BULLET_SIZE: 3,
        PARTICLE_COUNT: 12,
        TRAIL_LENGTH: 8,
        STARFIELD_DENSITY: 80,
        NUKE_RANGE: 150,
        
        // Screen effects
        NUKE_SHAKE_INTENSITY: 15,
        NUKE_SHAKE_DURATION: 1.0,
        SHIP_DEATH_SHAKE_INTENSITY: 8,
        SHIP_DEATH_SHAKE_DURATION: 0.6,
        EXPLOSION_PARTICLE_MULTIPLIER: 3
    },
    
    // Three-layer color scheme
    COLORS: {
        GAME: {
            BACKGROUND: '#000814',
            SHIP: '#00f5ff',
            SHIP_THRUST: '#ff6b35',
            BULLET: '#ffd60a', 
            ASTEROID: '#8d99ae',
            PARTICLE: '#ff7b00',
            TRAIL: '#00b4d8'
        },
        GUI: {
            TEXT: '#ffffff',
            PANEL_BG: 'rgba(8, 24, 40, 0.9)',
            BUTTON_IDLE: '#2a3d54',
            BUTTON_HOVER: '#3d5a80',
            BUTTON_ACTIVE: '#ee6c4d',
            BUTTON_DISABLED: '#1a1a1a'
        },
        DEBUG: {
            BACKGROUND: 'rgba(0, 20, 0, 0.85)',
            TEXT: '#00ff41',
            HIGHLIGHT: '#ffff00',
            WARNING: '#ff6b6b'
        }
    },
    
    // Gameplay constants
    GAMEPLAY: {
        STARTING_LIVES: 3,
        ASTEROID_COUNT: 6,
        POINTS_SMALL: 100,
        POINTS_MEDIUM: 50, 
        POINTS_LARGE: 20,
        NUKE_COST: 300,
        RESPAWN_TIME: 2.5
    },
    
    // UI layout for different layers
    UI: {
        HUD_MARGIN: 15,
        NUKE_BUTTON: { x: 650, y: 15, width: 130, height: 35 },
        WEAPON_PANEL: { x: 15, y: 450, width: 200, height: 120 },
        DEBUG_PANEL: { x: 450, y: 50, width: 330, height: 400 },
        DEBUG_RESET: { x: 600, y: 500, width: 120, height: 40 }
    }
};

/**
 * ActionEngine Game Class
 * 
 * This is the required ActionEngine Game class pattern. ActionEngine expects exactly
 * this class name and constructor signature. The framework will instantiate this
 * class and provide the three core systems: canvases, input, and audio.
 * 
 * ActionEngine handles all the complex setup - window management, canvas scaling,
 * input device detection, audio context creation, and more. You just implement
 * this class and ActionEngine takes care of everything else.
 */
class Game {
    /******* ActionEngine Required Constants *******/
	
	// ActionEngine uses a fixed coordinate system for reliable positioning
	// Your game should be designed for an 800x600 resolution
    // ActionEngine will handle proper canvas scaling across all devices
    static WIDTH = ASTEROIDS.WIDTH;
    static HEIGHT = ASTEROIDS.HEIGHT;
    
    /**
     * ActionEngine Game Constructor
     * 
     * ActionEngine requires this exact signature:
     * 
     * @param {Object} canvases - Three-layer canvas system
     *   - gameCanvas: Main content layer (you choose 2D or 3D context)
     *   - guiCanvas: UI overlay (always 2D)
     *   - debugCanvas: Development overlay (always 2D)
     *   - guiCtx: Pre-created 2D context for GUI layer
     *   - debugCtx: Pre-created 2D context for debug layer
     * 
     * @param {Object} input - ActionEngine's input management system
     *   Handles keyboard, mouse, touch, and element registration
     * 
     * @param {Object} audio - ActionEngine's audio synthesis system
     *   Provides multiple synthesis types and MIDI instrument support
     */
    constructor(canvases, input, audio) {
        /******* ActionEngine System References *******/
        // Store the systems ActionEngine provides
        this.input = input;
        this.audio = audio;
        
        /******* ActionEngine Three-Layer Canvas System *******/
        // ActionEngine provides three rendering layers with automatic scaling:
        
        // Game layer: Your main content (2D or 3D)
        this.gameCanvas = canvases.gameCanvas;
        this.gameCtx = this.gameCanvas.getContext('2d');
        
        // GUI layer: UI elements, always renders above game layer
        this.guiCanvas = canvases.guiCanvas;
        this.guiCtx = canvases.guiCtx; // ActionEngine provides this context
        
        // Debug layer: Development tools, renders above all
        this.debugCanvas = canvases.debugCanvas;
        this.debugCtx = canvases.debugCtx; // ActionEngine provides this context
        
        /******* Game State *******/
        this.gameState = 'startScreen'; // Start with intro screen
        this.score = 0;
        this.lives = ASTEROIDS.GAMEPLAY.STARTING_LIVES;
        this.level = 1;
        this.respawnTimer = 0;
        this.frameCount = 0;
        this.lastTime = performance.now();
        
        /******* Game Objects *******/
        this.ship = null;
        this.bullets = [];
        this.asteroids = [];
        this.particles = [];
        this.stars = [];
        
        /******* Visual Effects *******/
        this.screenFlash = 0; // Screen flash intensity (0-1)
        this.nukeCircle = { active: false, radius: 0, maxRadius: 0, x: 0, y: 0 };
        this.screenShake = { intensity: 0, duration: 0 };
        
        /******* ActionEngine Input System Setup *******/
        // This is where we demonstrate ActionEngine's comprehensive input capabilities
        this.setupActionEngineInputDemo();
        
        /******* Basic Audio Integration *******/
        this.setupAudio();
        
        /******* Initialize Game Content *******/
        this.createStarfield();
        // Ship and asteroids will be created when game starts
        
        console.log('ActionEngine Input Demo Ready!');
        console.log('Demonstrating three-layer input system and element registration');
    }
    
    /******* ACTIONENGINE INPUT SYSTEM DEMONSTRATION *******/
    
    /**
     * Comprehensive ActionEngine Input Setup
     * 
     * This method demonstrates every input feature ActionEngine provides:
     * - Element registration with bounds functions
     * - Three-layer input targeting (gui/debug/game)
     * - Hover state management
     * - Active/inactive element states
     * - Mouse button differentiation
     * - Input priority and event cascading
     * 
     * ActionEngine handles all the complexity - you just register elements and
     * check their states. No manual hit testing or coordinate transformation needed.
     */
    setupActionEngineInputDemo() {
        /******* GUI LAYER ELEMENTS *******/
        // GUI layer is the default for UI elements
        
        // Nuke Button - Demonstrates conditional element availability and right-click
        this.nukeButton = {
            id: 'nuke_button',
            ...ASTEROIDS.UI.NUKE_BUTTON,
            enabled: false,
            hovered: false
        };
        
        // Register with ActionEngine's input system
        // When you don't specify a layer, elements go to GUI layer (default)
        this.input.registerElement(this.nukeButton.id, {
            bounds: () => ({
                x: this.nukeButton.x,
                y: this.nukeButton.y,
                width: this.nukeButton.width,
                height: this.nukeButton.height
            })
        });
        
        // Weapon Selection Panel - Demonstrates multiple related elements
        this.weaponButtons = [
            {
                id: 'weapon_basic',
                name: 'Basic',
                x: ASTEROIDS.UI.WEAPON_PANEL.x + 10,
                y: ASTEROIDS.UI.WEAPON_PANEL.y + 30,
                width: 80,
                height: 25,
                selected: true,
                fireRate: 0.3
            },
            {
                id: 'weapon_rapid',
                name: 'Rapid',
                x: ASTEROIDS.UI.WEAPON_PANEL.x + 100,
                y: ASTEROIDS.UI.WEAPON_PANEL.y + 30,
                width: 80,
                height: 25,
                selected: false,
                fireRate: 0.15
            },
            {
                id: 'weapon_spread',
                name: 'Spread',
                x: ASTEROIDS.UI.WEAPON_PANEL.x + 10,
                y: ASTEROIDS.UI.WEAPON_PANEL.y + 65,
                width: 80,
                height: 25,
                selected: false,
                fireRate: 0.4
            }
        ];
        
        // Register all weapon buttons
        this.weaponButtons.forEach(button => {
            this.input.registerElement(button.id, {
                bounds: () => ({
                    x: button.x,
                    y: button.y,
                    width: button.width,
                    height: button.height
                })
            });
        });
        
        /******* START SCREEN BUTTON *******/
        // Button for starting the game from intro screen
        this.startButton = {
            id: 'start_game',
            x: ASTEROIDS.WIDTH / 2 - 120,
            y: ASTEROIDS.HEIGHT / 2 + 50,
            width: 240,
            height: 60,
            hovered: false
        };
        
        this.input.registerElement(this.startButton.id, {
            bounds: () => ({
                x: this.startButton.x,
                y: this.startButton.y,
                width: this.startButton.width,
                height: this.startButton.height
            })
        });
        
        /******* GAME OVER RESET BUTTON *******/
        // Button for restarting when game is over
        this.gameOverResetButton = {
            id: 'game_over_reset',
            x: ASTEROIDS.WIDTH / 2 - 100,
            y: ASTEROIDS.HEIGHT / 2 + 80,
            width: 200,
            height: 50,
            hovered: false
        };
        
        this.input.registerElement(this.gameOverResetButton.id, {
            bounds: () => ({
                x: this.gameOverResetButton.x,
                y: this.gameOverResetButton.y,
                width: this.gameOverResetButton.width,
                height: this.gameOverResetButton.height
            })
        });
        
        /******* DEBUG LAYER ELEMENTS *******/
        // Debug layer has highest input priority - these elements are processed first
        
        // Debug reset button - following original demo.js pattern
        this.debugResetButton = {
            x: ASTEROIDS.UI.DEBUG_RESET.x,
            y: ASTEROIDS.UI.DEBUG_RESET.y,
            width: ASTEROIDS.UI.DEBUG_RESET.width,
            height: ASTEROIDS.UI.DEBUG_RESET.height,
            hovered: false
        };
        
        // Debug info toggle button
        this.debugInfoButton = {
            x: ASTEROIDS.UI.DEBUG_PANEL.x + 10,
            y: ASTEROIDS.UI.DEBUG_PANEL.y + 350,
            width: 100,
            height: 30,
            hovered: false
        };
        
        // Register debug elements using simple string IDs like original demo
        this.input.registerElement(
            "debugResetButton",
            {
                bounds: () => ({
                    x: this.debugResetButton.x,
                    y: this.debugResetButton.y,
                    width: this.debugResetButton.width,
                    height: this.debugResetButton.height
                })
            },
            "debug"
        );
        
        this.input.registerElement(
            "debugInfoButton",
            {
                bounds: () => ({
                    x: this.debugInfoButton.x,
                    y: this.debugInfoButton.y,
                    width: this.debugInfoButton.width,
                    height: this.debugInfoButton.height
                })
            },
            "debug"
        );
        
        /******* GAME LAYER ELEMENTS *******/
        // Game layer has lowest priority - processed last in the cascade
        // We'll register asteroids as interactive elements here
        this.asteroidElements = new Map(); // Use Map for better tracking
        this.nextAsteroidId = 0; // Unique ID counter
        
        /******* Input State Tracking *******/
        this.currentWeapon = this.weaponButtons[0];
        this.fireTimer = 0;
        this.debugInfoVisible = true;
        this.debugOverlayVisible = false; // Track debug overlay state
        
        console.log('ActionEngine Input: Elements registered across all three layers');
    }
    
    /**
     * Register Asteroid as Interactive Game Element
     * 
     * Demonstrates dynamic element registration during gameplay.
     * ActionEngine allows you to register and unregister elements at any time.
     * 
     * @param {Object} asteroid - The asteroid game object
     */
    registerAsteroidElement(asteroid) {
        // Generate unique ID to avoid conflicts
        const elementId = `asteroid_${this.nextAsteroidId++}`;
        asteroid.elementId = elementId; // Store ID on asteroid for cleanup
        
        // Register on GAME layer (lowest priority)
        this.input.registerElement(elementId, {
            bounds: () => ({
                x: asteroid.x - asteroid.radius,
                y: asteroid.y - asteroid.radius,
                width: asteroid.radius * 2,
                height: asteroid.radius * 2
            })
        }, 'game'); // Explicit game layer targeting
        
        // Track for cleanup
        this.asteroidElements.set(elementId, asteroid);
    }
    
    /**
     * Clean up destroyed asteroid elements
     * Properly unregister elements from ActionEngine's input system
     */
    unregisterAsteroidElement(asteroid) {
        if (asteroid.elementId && this.asteroidElements.has(asteroid.elementId)) {
            // Remove from our tracking
            this.asteroidElements.delete(asteroid.elementId);
            // Note: ActionEngine automatically handles element cleanup when objects are removed
            console.log(`Unregistered asteroid element: ${asteroid.elementId}`);
        }
    }
    
    /******* BASIC AUDIO INTEGRATION *******/
    
    /**
     * Simple audio setup - this demo focuses on input, not audio
     * See the breakout demo for comprehensive audio system coverage
     */
    setupAudio() {
        this.audio.createSweepSound('shoot', {
            startFreq: 800, endFreq: 400, type: 'square', duration: 0.1,
            envelope: { attack: 0.01, decay: 0.09, sustain: 0, release: 0 }
        });
        
        this.audio.createComplexSound('explode', {
            frequencies: [150, 300, 450], types: ['sawtooth', 'triangle', 'sine'],
            mix: [0.5, 0.3, 0.2], duration: 0.4,
            envelope: { attack: 0.01, decay: 0.15, sustain: 0.2, release: 0.24 }
        });
        
        this.audio.createSweepSound('thrust', {
            startFreq: 120, endFreq: 180, type: 'triangle', duration: 0.1,
            envelope: { attack: 0.02, decay: 0.08, sustain: 0, release: 0 }
        });
        
        this.audio.createSweepSound('nuke', {
            startFreq: 60, endFreq: 400, type: 'sawtooth', duration: 1.0,
            envelope: { attack: 0.05, decay: 0.3, sustain: 0.4, release: 0.65 }
        });
    }
    
    /******* ACTIONENGINE FRAMEWORK HOOKS *******/
    
    /**
     * action_update() - ActionEngine Framework Hook
     * 
     * ActionEngine calls this method automatically each frame. You don't need to
     * set up a game loop or manage timing - ActionEngine handles all of that.
     * This is where you put your main game logic that runs every frame.
     * 
     * ActionEngine ensures this runs at a consistent rate and provides you with
     * a clean, predictable update cycle.
     */
    action_update() {
        // Calculate delta time for smooth movement
        const currentTime = performance.now();
        const deltaTime = Math.min((currentTime - this.lastTime) / 1000, 0.25);
        this.lastTime = currentTime;
        this.frameCount++;
        
        // Main update logic
        this.handleAllInputTypes(deltaTime);
        this.updateGameObjects(deltaTime);
        this.updateTimers(deltaTime);
        
        if (this.gameState === 'playing') {
            this.checkCollisions();
            this.checkLevelComplete();
        }
        
        this.updateEffects(deltaTime);
    }
    
    /**
     * action_draw() - ActionEngine Framework Hook
     * 
     * ActionEngine calls this method automatically each frame after action_update().
     * This is where you render to the three canvas layers ActionEngine provides.
     * 
     * ActionEngine handles canvas scaling, device pixel ratios, and ensures your
     * fixed 800x600 coordinate system works on any screen size.
     */
    action_draw() {
        // Render across ActionEngine's three-layer system
        this.drawGameLayer();
        this.drawGUILayer();
        this.drawDebugLayer();
    }
    
    /******* COMPREHENSIVE INPUT DEMONSTRATION *******/
    
    /**
     * Complete ActionEngine Input API Demonstration
     * 
     * This method showcases every input method ActionEngine provides:
     * - Continuous and edge-triggered keyboard input
     * - All mouse button variations (left, right, middle)
     * - Pointer position tracking
     * - Element interaction across all three layers
     * - Input priority and cascading
     */
    handleAllInputTypes(deltaTime) {
        /******* CONTINUOUS KEYBOARD INPUT *******/
        // ActionEngine's isKeyPressed() checks if a key is currently held down
        if (this.ship && this.gameState === 'playing') {
            if (this.input.isKeyPressed('DirLeft')) {
                this.ship.angle -= ASTEROIDS.PHYSICS.SHIP_ROTATION_SPEED * deltaTime;
            }
            if (this.input.isKeyPressed('DirRight')) {
                this.ship.angle += ASTEROIDS.PHYSICS.SHIP_ROTATION_SPEED * deltaTime;
            }
            
            // Ship thrust with physics
            this.ship.thrust = this.input.isKeyPressed('DirUp');
            if (this.ship.thrust) {
                const thrustX = Math.cos(this.ship.angle - Math.PI / 2) * ASTEROIDS.PHYSICS.SHIP_THRUST * deltaTime;
                const thrustY = Math.sin(this.ship.angle - Math.PI / 2) * ASTEROIDS.PHYSICS.SHIP_THRUST * deltaTime;
                
                this.ship.vx += thrustX;
                this.ship.vy += thrustY;
                
                // Limit max speed
                const speed = Math.sqrt(this.ship.vx * this.ship.vx + this.ship.vy * this.ship.vy);
                if (speed > ASTEROIDS.PHYSICS.SHIP_MAX_SPEED) {
                    this.ship.vx = (this.ship.vx / speed) * ASTEROIDS.PHYSICS.SHIP_MAX_SPEED;
                    this.ship.vy = (this.ship.vy / speed) * ASTEROIDS.PHYSICS.SHIP_MAX_SPEED;
                }
                
                this.audio.play('thrust', { volume: 0.01 });
            }
        }
        
        /******* EDGE-TRIGGERED KEYBOARD INPUT *******/
        // ActionEngine's isKeyJustPressed() detects the moment a key is pressed
        
        if (this.input.isKeyJustPressed('Action1')) {
            if (this.gameState === 'startScreen') {
                // Start game when Action1 pressed on start screen
                this.startGame();
            } else if (this.gameState === 'gameOver') {
                // Reset game when Action1 pressed during game over
                this.resetGame();
            } else if (this.ship && this.gameState === 'playing') {
                // Fire weapon during normal gameplay
                this.fireWeapon();
            }
        }
        
        /******* CONTINUOUS FIRING FOR RAPID WEAPON *******/
        // Allow rapid fire when Action1 is held down and rapid weapon is selected
        if (this.input.isKeyPressed('Action1') && this.ship && this.gameState === 'playing') {
            if (this.currentWeapon.name === 'Rapid' && this.fireTimer <= 0) {
                this.fireWeapon();
            }
        }
        
        // Demonstrate all Action keys
        if (this.input.isKeyJustPressed('Action2')) {
            console.log('Action2 pressed - cycling weapon');
            this.cycleWeapon();
        }
        
        if (this.input.isKeyJustPressed('Action3')) {
            console.log('Action3 pressed - spawn extra asteroid for testing');
            if (this.asteroids.length < 15) {
                const asteroid = this.createAsteroid('medium');
                this.asteroids.push(asteroid);
                this.registerAsteroidElement(asteroid, this.asteroids.length - 1);
            }
        }
        
        if (this.input.isKeyJustPressed('Action4')) {
            console.log('Action4 pressed - clear all bullets');
            this.bullets = [];
        }
        
        /******* COMPREHENSIVE MOUSE INPUT DEMONSTRATION *******/
        // ActionEngine provides detailed mouse button detection
        
        // Legacy pointer method (for compatibility)
        if (this.input.isPointerJustDown()) {
            console.log('Pointer down (legacy method)');
        }
        
        // Modern mouse button differentiation
        if (this.input.isLeftMouseButtonJustPressed()) {
            console.log('Left mouse button pressed');
            // Mouse click does not fire - only clicks on registered elements
        }
        
        if (this.input.isRightMouseButtonJustPressed()) {
            console.log('Right mouse button pressed');
            // Right-click activates nuke
            this.tryActivateNuke();
        }
        
        if (this.input.isMiddleMouseButtonJustPressed()) {
            console.log('Middle mouse button pressed');
            this.cycleWeapon();
        }
        
        // Generic button checking (0=left, 1=middle, 2=right)
        if (this.input.isMouseButtonJustPressed(0)) {
            console.log('Generic left button check');
        }
        
        // Continuous mouse states
        if (this.input.isLeftMouseButtonDown() && this.frameCount % 60 === 0) {
            console.log('Left button held (logged every second)');
        }
        
        /******* POINTER POSITION TRACKING *******/
        // ActionEngine provides precise coordinates in your game's coordinate space
        const pointer = this.input.getPointerPosition();
        
        // Mouse aiming (hold Action2 to aim toward pointer)
        if (this.input.isKeyPressed('Action2') && this.ship && this.gameState === 'playing') {
            const dx = pointer.x - this.ship.x;
            const dy = pointer.y - this.ship.y;
            const targetAngle = Math.atan2(dy, dx) + Math.PI / 2;
            
            let angleDiff = targetAngle - this.ship.angle;
            while (angleDiff > Math.PI) angleDiff -= Math.PI * 2;
            while (angleDiff < -Math.PI) angleDiff += Math.PI * 2;
            
            this.ship.angle += angleDiff * 3 * deltaTime;
        }
        
        /******* THREE-LAYER INPUT PROCESSING *******/
        // ActionEngine processes input in layer priority order:
        // Debug (highest) -> GUI (medium) -> Game (lowest)
        
        this.handleDebugLayerInput();
        this.handleGUILayerInput();
        this.handleGameLayerInput();
        
        /******* SPECIAL ACTIONENGINE KEYS *******/
        // ActionEngine provides special system keys
        if (this.input.isKeyJustPressed('ActionDebugToggle')) {
            this.debugOverlayVisible = !this.debugOverlayVisible;
            
            // No need to set active state - elements work when registered
            
            console.log(`Debug overlay ${this.debugOverlayVisible ? 'shown' : 'hidden'} (F9)`);
        }
    }
    
    drawDebugControls() {
        // Reset button - following original demo.js drawing pattern
        this.debugCtx.fillStyle = this.debugResetButton.hovered ? '#ff6666' : '#ff4444';
        this.debugCtx.fillRect(this.debugResetButton.x, this.debugResetButton.y, this.debugResetButton.width, this.debugResetButton.height);
        
        this.debugCtx.strokeStyle = '#ffffff';
        this.debugCtx.lineWidth = 2;
        this.debugCtx.strokeRect(this.debugResetButton.x, this.debugResetButton.y, this.debugResetButton.width, this.debugResetButton.height);
        
        this.debugCtx.fillStyle = '#ffffff';
        this.debugCtx.font = '14px Arial';
        this.debugCtx.textAlign = 'center';
        this.debugCtx.fillText('RESET GAME', this.debugResetButton.x + this.debugResetButton.width / 2, this.debugResetButton.y + this.debugResetButton.height / 2 + 5);
        
        // Info toggle button
        this.debugCtx.fillStyle = this.debugInfoButton.hovered ? '#44aa44' : '#44ff44';
        this.debugCtx.fillRect(this.debugInfoButton.x, this.debugInfoButton.y, this.debugInfoButton.width, this.debugInfoButton.height);
        
        this.debugCtx.strokeStyle = '#ffffff';
        this.debugCtx.strokeRect(this.debugInfoButton.x, this.debugInfoButton.y, this.debugInfoButton.width, this.debugInfoButton.height);
        
        this.debugCtx.fillStyle = '#000000';
        this.debugCtx.font = '12px Arial';
        this.debugCtx.fillText(this.debugInfoVisible ? 'Hide Info' : 'Show Info', this.debugInfoButton.x + this.debugInfoButton.width / 2, this.debugInfoButton.y + this.debugInfoButton.height / 2 + 3);
    }
    
    /**
     * Check if pointer is over any UI element
     * Prevents firing when clicking on buttons
     */
    isClickingUI() {
        return (
            this.input.isElementHovered(this.nukeButton.id) ||
            this.weaponButtons.some(btn => this.input.isElementHovered(btn.id))
        );
    }
    
    /**
     * Debug Layer Input (Highest Priority)
     * 
     * ActionEngine processes debug layer input first. When the debug overlay
     * is visible (ActionDebugToggle key), these elements get input priority over everything else.
     */
    handleDebugLayerInput() {
        // Set debug element active states based on overlay visibility
        // Only allow interaction when debug overlay is shown
        this.input.setElementActive('debugResetButton', 'debug', this.debugOverlayVisible);
        this.input.setElementActive('debugInfoButton', 'debug', this.debugOverlayVisible);
        
        // Only process debug input when overlay is visible
        if (!this.debugOverlayVisible) return;
        
        // Handle debug reset button - using original demo.js pattern
        this.debugResetButton.hovered = this.input.isElementHovered("debugResetButton", "debug");
        
        if (this.input.isElementJustPressed("debugResetButton", "debug")) {
            this.resetGame();
        }
        
        // Handle debug info toggle
        this.debugInfoButton.hovered = this.input.isElementHovered("debugInfoButton", "debug");
        
        if (this.input.isElementJustPressed("debugInfoButton", "debug")) {
            this.debugInfoVisible = !this.debugInfoVisible;
        }
    }
    
    /**
     * GUI Layer Input (Medium Priority)
     * 
     * ActionEngine processes GUI layer input after debug layer but before game layer.
     * This is where most UI elements live.
     */
    handleGUILayerInput() {
        // Update nuke button state
        this.nukeButton.enabled = this.score >= ASTEROIDS.GAMEPLAY.NUKE_COST;
        this.nukeButton.hovered = this.input.isElementHovered(this.nukeButton.id);
        
        // ActionEngine's element active/inactive system
        this.input.setElementActive(this.nukeButton.id, 'gui', this.nukeButton.enabled);
        
        // Nuke button click handling
        if (this.input.isElementJustPressed(this.nukeButton.id)) {
            this.tryActivateNuke();
        }
        
        // Weapon selection buttons (only when playing)
        if (this.gameState === 'playing') {
            this.weaponButtons.forEach(button => {
                button.hovered = this.input.isElementHovered(button.id);
                
                if (this.input.isElementJustPressed(button.id)) {
                    // Deselect all weapons
                    this.weaponButtons.forEach(btn => btn.selected = false);
                    // Select this weapon
                    button.selected = true;
                    this.currentWeapon = button;
                    console.log(`Weapon changed to ${button.name}`);
                }
            });
        }
        
        // Start screen button
        if (this.gameState === 'startScreen') {
            this.startButton.hovered = this.input.isElementHovered(this.startButton.id);
            
            if (this.input.isElementJustPressed(this.startButton.id)) {
                this.startGame();
            }
        }
        
        // Game over reset button
        if (this.gameState === 'gameOver') {
            this.gameOverResetButton.hovered = this.input.isElementHovered(this.gameOverResetButton.id);
            
            if (this.input.isElementJustPressed(this.gameOverResetButton.id)) {
                this.resetGame();
            }
        }
    }
    
    /**
     * Game Layer Input (Lowest Priority)
     * 
     * ActionEngine processes game layer input last. These elements only receive
     * input if no higher priority layer handled it.
     */
    handleGameLayerInput() {
        // Check asteroid clicks using new Map-based system
        for (const [elementId, asteroid] of this.asteroidElements) {
            if (this.input.isElementJustPressed(elementId, 'game')) {
                console.log(`Asteroid ${elementId} clicked!`);
                this.destroyAsteroid(asteroid);
                break; // Only handle one click per frame
            }
        }
    }
    
    /**
     * Try to activate nuke (right-click only)
     */
    tryActivateNuke() {
        if (!this.nukeButton.enabled || !this.ship) return;
        
        this.score -= ASTEROIDS.GAMEPLAY.NUKE_COST;
        
        // Store ship position for nuke center
        const nukeX = this.ship.x;
        const nukeY = this.ship.y;
        
        // Destroy all asteroids within range
        const toDestroy = [];
        this.asteroids.forEach(asteroid => {
            const dx = asteroid.x - nukeX;
            const dy = asteroid.y - nukeY;
            const distance = Math.sqrt(dx * dx + dy * dy);
            
            if (distance <= ASTEROIDS.VISUAL.NUKE_RANGE) {
                toDestroy.push(asteroid);
            }
        });
        
        toDestroy.forEach(asteroid => this.destroyAsteroid(asteroid));
        
        // NUKE VISUAL EFFECTS
        this.screenFlash = 1.0;
        
        // Expanding nuke circle animation
        this.nukeCircle = {
            active: true,
            radius: 0,
            maxRadius: ASTEROIDS.VISUAL.NUKE_RANGE,
            x: nukeX,
            y: nukeY
        };
        
        // Powerful screen shake
        this.screenShake = { 
            intensity: ASTEROIDS.VISUAL.NUKE_SHAKE_INTENSITY, 
            duration: ASTEROIDS.VISUAL.NUKE_SHAKE_DURATION 
        };
        
        this.audio.play('nuke');
        console.log(`Nuke destroyed ${toDestroy.length} asteroids`);
    }
    
    /**
     * Create spectacular ship explosion effect
     */
    createShipExplosion(x, y) {
        // Create lots of particles for dramatic ship explosion
        const particleCount = ASTEROIDS.VISUAL.PARTICLE_COUNT * ASTEROIDS.VISUAL.EXPLOSION_PARTICLE_MULTIPLIER;
        
        for (let i = 0; i < particleCount; i++) {
            const angle = (Math.PI * 2 * i) / particleCount;
            const speed = Math.random() * 200 + 100; // Faster than asteroid particles
            const size = Math.random() * 4 + 2;
            
            this.particles.push({
                x: x,
                y: y,
                vx: Math.cos(angle) * speed,
                vy: Math.sin(angle) * speed,
                life: Math.random() * 1.5 + 1.0,
                maxLife: 2.5,
                size: size,
                color: Math.random() > 0.5 ? ASTEROIDS.COLORS.GAME.SHIP_THRUST : ASTEROIDS.COLORS.GAME.PARTICLE
            });
        }
    }
    
    /******* GAME LOGIC *******/
    
    createStarfield() {
        this.stars = [];
        for (let i = 0; i < ASTEROIDS.VISUAL.STARFIELD_DENSITY; i++) {
            this.stars.push({
                x: Math.random() * ASTEROIDS.WIDTH,
                y: Math.random() * ASTEROIDS.HEIGHT,
                brightness: Math.random() * 0.8 + 0.2,
                twinkle: Math.random() * Math.PI * 2
            });
        }
    }
    
    spawnShip() {
        this.ship = {
            x: ASTEROIDS.WIDTH / 2,
            y: ASTEROIDS.HEIGHT / 2,
            vx: 0,
            vy: 0,
            angle: 0,
            thrust: false,
            trail: []
        };
    }
    
    createAsteroidField() {
        this.asteroids = [];
        this.asteroidElements.clear(); // Clear the Map
        
        for (let i = 0; i < ASTEROIDS.GAMEPLAY.ASTEROID_COUNT; i++) {
            const asteroid = this.createAsteroid('large');
            this.asteroids.push(asteroid);
            this.registerAsteroidElement(asteroid); // No index needed
        }
    }
    
    createAsteroid(size, x, y) {
        const sizes = { large: 30, medium: 20, small: 12 };
        
        const asteroid = {
            x: x ?? Math.random() * ASTEROIDS.WIDTH,
            y: y ?? Math.random() * ASTEROIDS.HEIGHT,
            vx: (Math.random() - 0.5) * ASTEROIDS.PHYSICS.ASTEROID_MAX_SPEED,
            vy: (Math.random() - 0.5) * ASTEROIDS.PHYSICS.ASTEROID_MAX_SPEED,
            angle: 0,
            rotation: (Math.random() - 0.5) * 3,
            size: size,
            radius: sizes[size],
            points: { large: 20, medium: 50, small: 100 }[size]
        };
        
        // Avoid spawning on ship
        if (this.ship) {
            const dx = asteroid.x - this.ship.x;
            const dy = asteroid.y - this.ship.y;
            if (Math.sqrt(dx * dx + dy * dy) < 80) {
                asteroid.x = Math.random() * ASTEROIDS.WIDTH;
                asteroid.y = Math.random() * ASTEROIDS.HEIGHT;
            }
        }
        
        return asteroid;
    }
    
    fireWeapon() {
        if (this.fireTimer > 0) return;
        
        this.fireTimer = this.currentWeapon.fireRate;
        
        if (this.currentWeapon.name === 'Spread') {
            // Fire three bullets in a spread
            for (let i = -1; i <= 1; i++) {
                const angle = this.ship.angle + i * 0.3;
                this.createBullet(angle);
            }
        } else {
            this.createBullet(this.ship.angle);
        }
        
        this.audio.play('shoot');
    }
    
    createBullet(angle) {
        this.bullets.push({
            x: this.ship.x + Math.cos(angle - Math.PI / 2) * ASTEROIDS.VISUAL.SHIP_SIZE,
            y: this.ship.y + Math.sin(angle - Math.PI / 2) * ASTEROIDS.VISUAL.SHIP_SIZE,
            vx: Math.cos(angle - Math.PI / 2) * ASTEROIDS.PHYSICS.BULLET_SPEED,
            vy: Math.sin(angle - Math.PI / 2) * ASTEROIDS.PHYSICS.BULLET_SPEED,
            life: ASTEROIDS.PHYSICS.BULLET_LIFETIME
        });
    }
    
    cycleWeapon() {
        const currentIndex = this.weaponButtons.indexOf(this.currentWeapon);
        const nextIndex = (currentIndex + 1) % this.weaponButtons.length;
        
        this.weaponButtons.forEach(btn => btn.selected = false);
        this.weaponButtons[nextIndex].selected = true;
        this.currentWeapon = this.weaponButtons[nextIndex];
    }
    
    destroyAsteroid(asteroid) {
        const index = this.asteroids.indexOf(asteroid);
        if (index === -1) return;
        
        // Clean up element BEFORE removing asteroid from array
        this.unregisterAsteroidElement(asteroid);
        
        // Remove from asteroid array
        this.asteroids.splice(index, 1);
        this.score += asteroid.points;
        
        // Create explosion particles
        for (let i = 0; i < ASTEROIDS.VISUAL.PARTICLE_COUNT; i++) {
            const angle = (Math.PI * 2 * i) / ASTEROIDS.VISUAL.PARTICLE_COUNT;
            this.particles.push({
                x: asteroid.x,
                y: asteroid.y,
                vx: Math.cos(angle) * 100,
                vy: Math.sin(angle) * 100,
                life: 1.0,
                maxLife: 1.0
            });
        }
        
        // Split large/medium asteroids
        if (asteroid.size === 'large') {
            for (let i = 0; i < 2; i++) {
                const newAsteroid = this.createAsteroid('medium', asteroid.x, asteroid.y);
                this.asteroids.push(newAsteroid);
                this.registerAsteroidElement(newAsteroid); // No index needed
            }
        } else if (asteroid.size === 'medium') {
            for (let i = 0; i < 2; i++) {
                const newAsteroid = this.createAsteroid('small', asteroid.x, asteroid.y);
                this.asteroids.push(newAsteroid);
                this.registerAsteroidElement(newAsteroid); // No index needed
            }
        }
        
        this.audio.play('explode');
    }
    
    updateGameObjects(deltaTime) {
        // Update ship (only if it exists)
        if (this.ship) {
            this.ship.x += this.ship.vx * deltaTime;
            this.ship.y += this.ship.vy * deltaTime;
            
            // Apply friction
            this.ship.vx *= ASTEROIDS.PHYSICS.SHIP_FRICTION;
            this.ship.vy *= ASTEROIDS.PHYSICS.SHIP_FRICTION;
            
            // Wrap around screen
            this.ship.x = (this.ship.x + ASTEROIDS.WIDTH) % ASTEROIDS.WIDTH;
            this.ship.y = (this.ship.y + ASTEROIDS.HEIGHT) % ASTEROIDS.HEIGHT;
            
            // Update trail
            this.ship.trail.push({ x: this.ship.x, y: this.ship.y });
            if (this.ship.trail.length > ASTEROIDS.VISUAL.TRAIL_LENGTH) {
                this.ship.trail.shift();
            }
        }
        
        // Update bullets (with ship existence check to prevent crash)
        for (let i = this.bullets.length - 1; i >= 0; i--) {
            const bullet = this.bullets[i];
            bullet.x += bullet.vx * deltaTime;
            bullet.y += bullet.vy * deltaTime;
            bullet.life -= deltaTime;
            
            // Wrap around screen
            bullet.x = (bullet.x + ASTEROIDS.WIDTH) % ASTEROIDS.WIDTH;
            bullet.y = (bullet.y + ASTEROIDS.HEIGHT) % ASTEROIDS.HEIGHT;
            
            if (bullet.life <= 0) {
                this.bullets.splice(i, 1);
            }
        }
        
        // Update asteroids
        this.asteroids.forEach(asteroid => {
            asteroid.x += asteroid.vx * deltaTime;
            asteroid.y += asteroid.vy * deltaTime;
            asteroid.angle += asteroid.rotation * deltaTime;
            
            // Wrap around screen
            asteroid.x = (asteroid.x + ASTEROIDS.WIDTH) % ASTEROIDS.WIDTH;
            asteroid.y = (asteroid.y + ASTEROIDS.HEIGHT) % ASTEROIDS.HEIGHT;
        });
    }
    
    updateTimers(deltaTime) {
        this.fireTimer = Math.max(0, this.fireTimer - deltaTime);
        this.respawnTimer = Math.max(0, this.respawnTimer - deltaTime);
        
        // Respawn ship if needed
        if (this.respawnTimer === 0 && !this.ship && this.lives > 0 && this.gameState === 'playing') {
            this.spawnShip();
        }
    }
    
    updateEffects(deltaTime) {
        // Update particles
        for (let i = this.particles.length - 1; i >= 0; i--) {
            const particle = this.particles[i];
            particle.x += particle.vx * deltaTime;
            particle.y += particle.vy * deltaTime;
            particle.life -= deltaTime;
            
            if (particle.life <= 0) {
                this.particles.splice(i, 1);
            }
        }
        
        // Update screen flash effect
        if (this.screenFlash > 0) {
            this.screenFlash -= deltaTime * 2; // Fade out quickly
            if (this.screenFlash < 0) this.screenFlash = 0;
        }
        
        // Update nuke circle expansion
        if (this.nukeCircle.active) {
            this.nukeCircle.radius += deltaTime * 300; // Expand quickly
            if (this.nukeCircle.radius >= this.nukeCircle.maxRadius) {
                this.nukeCircle.active = false;
            }
        }
        
        // Update screen shake
        if (this.screenShake.duration > 0) {
            this.screenShake.duration -= deltaTime;
            if (this.screenShake.duration <= 0) {
                this.screenShake.intensity = 0;
            }
        }
        
        // Update star twinkle
        this.stars.forEach(star => {
            star.twinkle += deltaTime * 2;
        });
    }
    
    checkCollisions() {
        if (!this.ship) return;
        
        // Bullet-asteroid collisions
        for (let i = this.bullets.length - 1; i >= 0; i--) {
            const bullet = this.bullets[i];
            
            for (let j = this.asteroids.length - 1; j >= 0; j--) {
                const asteroid = this.asteroids[j];
                
                const dx = bullet.x - asteroid.x;
                const dy = bullet.y - asteroid.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                if (distance < asteroid.radius) {
                    this.bullets.splice(i, 1);
                    this.destroyAsteroid(asteroid);
                    break;
                }
            }
        }
        
        // Ship-asteroid collisions (only if ship exists)
        if (this.ship) {
            for (let i = 0; i < this.asteroids.length; i++) {
                const asteroid = this.asteroids[i];
                const dx = this.ship.x - asteroid.x;
                const dy = this.ship.y - asteroid.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                if (distance < asteroid.radius + ASTEROIDS.VISUAL.SHIP_SIZE) {
                    this.destroyShip();
                    break; // Exit loop immediately after ship destruction
                }
            }
        }
    }
    
    destroyShip() {
        // Store ship position for explosion
        const shipX = this.ship.x;
        const shipY = this.ship.y;
        
        this.ship = null;
        this.lives--;
        this.respawnTimer = ASTEROIDS.GAMEPLAY.RESPAWN_TIME;
        
        // Create dramatic ship explosion
        this.createShipExplosion(shipX, shipY);
        
        // Screen shake effect
        this.screenShake = { 
            intensity: ASTEROIDS.VISUAL.SHIP_DEATH_SHAKE_INTENSITY, 
            duration: ASTEROIDS.VISUAL.SHIP_DEATH_SHAKE_DURATION 
        };
        
        // Brief screen flash
        this.screenFlash = 0.4;
        
        if (this.lives <= 0) {
            this.gameState = 'gameOver';
        }
        
        this.audio.play('explode');
    }
    
    checkLevelComplete() {
        if (this.asteroids.length === 0) {
            this.level++;
            this.createAsteroidField();
        }
    }
    
    startGame() {
        // Transition from start screen to gameplay
        this.gameState = 'playing';
        this.score = 0;
        this.lives = ASTEROIDS.GAMEPLAY.STARTING_LIVES;
        this.level = 1;
        this.spawnShip();
        this.createAsteroidField();
        this.bullets = [];
        this.particles = [];
        console.log('Game started!');
    }
    
    resetGame() {
        this.gameState = 'playing';
        this.score = 0;
        this.lives = ASTEROIDS.GAMEPLAY.STARTING_LIVES;
        this.level = 1;
        this.spawnShip();
        this.createAsteroidField();
        this.bullets = [];
        this.particles = [];
    }
    
    /******* ACTIONENGINE THREE-LAYER RENDERING *******/
    
    /**
     * Game Layer Rendering
     * 
     * This is your main content layer. ActionEngine automatically scales this
     * to fit any screen while maintaining the 800x600 coordinate system.
     */
    drawGameLayer() {
        // Clear with space background
        this.gameCtx.fillStyle = ASTEROIDS.COLORS.GAME.BACKGROUND;
        this.gameCtx.fillRect(0, 0, ASTEROIDS.WIDTH, ASTEROIDS.HEIGHT);
        
        // Apply screen shake effect
        this.gameCtx.save();
        if (this.screenShake.intensity > 0) {
            const shakeX = (Math.random() - 0.5) * this.screenShake.intensity;
            const shakeY = (Math.random() - 0.5) * this.screenShake.intensity;
            this.gameCtx.translate(shakeX, shakeY);
        }
        
        this.drawStarfield();
        
        // Only draw game objects when not on start screen
        if (this.gameState !== 'startScreen') {
            this.drawGameObjects();
        }
        
        this.drawParticles();
        
        // Draw nuke expanding circle effect
        if (this.nukeCircle.active) {
            this.drawNukeCircle();
        }
        
        this.gameCtx.restore();
        
        // Draw screen flash effect (over everything)
        if (this.screenFlash > 0) {
            this.gameCtx.fillStyle = `rgba(255, 255, 255, ${this.screenFlash})`;
            this.gameCtx.fillRect(0, 0, ASTEROIDS.WIDTH, ASTEROIDS.HEIGHT);
        }
    }
    
    drawStarfield() {
        this.stars.forEach(star => {
            const brightness = star.brightness * (0.8 + 0.2 * Math.sin(star.twinkle));
            this.gameCtx.fillStyle = `rgba(255, 255, 255, ${brightness})`;
            this.gameCtx.fillRect(star.x, star.y, 1, 1);
        });
    }
    
    drawGameObjects() {
        // Draw ship trail
        if (this.ship && this.ship.trail.length > 1) {
            this.gameCtx.strokeStyle = ASTEROIDS.COLORS.GAME.TRAIL;
            this.gameCtx.lineWidth = 2;
            this.gameCtx.globalAlpha = 0.5;
            
            this.gameCtx.beginPath();
            this.gameCtx.moveTo(this.ship.trail[0].x, this.ship.trail[0].y);
            for (let i = 1; i < this.ship.trail.length; i++) {
                this.gameCtx.lineTo(this.ship.trail[i].x, this.ship.trail[i].y);
            }
            this.gameCtx.stroke();
            this.gameCtx.globalAlpha = 1;
        }
        
        // Draw ship
        if (this.ship) {
            this.drawShip();
        }
        
        // Draw bullets
        this.gameCtx.fillStyle = ASTEROIDS.COLORS.GAME.BULLET;
        this.bullets.forEach(bullet => {
            this.gameCtx.beginPath();
            this.gameCtx.arc(bullet.x, bullet.y, ASTEROIDS.VISUAL.BULLET_SIZE, 0, Math.PI * 2);
            this.gameCtx.fill();
        });
        
        // Draw asteroids
        this.asteroids.forEach(asteroid => {
            this.drawAsteroid(asteroid);
        });
    }
    
    drawShip() {
        this.gameCtx.save();
        this.gameCtx.translate(this.ship.x, this.ship.y);
        this.gameCtx.rotate(this.ship.angle);
        
        // Ship body
        this.gameCtx.strokeStyle = ASTEROIDS.COLORS.GAME.SHIP;
        this.gameCtx.lineWidth = 2;
        this.gameCtx.beginPath();
        this.gameCtx.moveTo(0, -ASTEROIDS.VISUAL.SHIP_SIZE);
        this.gameCtx.lineTo(-ASTEROIDS.VISUAL.SHIP_SIZE * 0.7, ASTEROIDS.VISUAL.SHIP_SIZE);
        this.gameCtx.lineTo(0, ASTEROIDS.VISUAL.SHIP_SIZE * 0.7);
        this.gameCtx.lineTo(ASTEROIDS.VISUAL.SHIP_SIZE * 0.7, ASTEROIDS.VISUAL.SHIP_SIZE);
        this.gameCtx.closePath();
        this.gameCtx.stroke();
        
        // Thrust flame
        if (this.ship.thrust) {
            this.gameCtx.strokeStyle = ASTEROIDS.COLORS.GAME.SHIP_THRUST;
            this.gameCtx.beginPath();
            this.gameCtx.moveTo(-ASTEROIDS.VISUAL.SHIP_SIZE * 0.3, ASTEROIDS.VISUAL.SHIP_SIZE);
            this.gameCtx.lineTo(0, ASTEROIDS.VISUAL.SHIP_SIZE * 1.5);
            this.gameCtx.lineTo(ASTEROIDS.VISUAL.SHIP_SIZE * 0.3, ASTEROIDS.VISUAL.SHIP_SIZE);
            this.gameCtx.stroke();
        }
        
        this.gameCtx.restore();
    }
    
    drawAsteroid(asteroid) {
        this.gameCtx.save();
        this.gameCtx.translate(asteroid.x, asteroid.y);
        this.gameCtx.rotate(asteroid.angle);
        
        this.gameCtx.strokeStyle = ASTEROIDS.COLORS.GAME.ASTEROID;
        this.gameCtx.lineWidth = 2;
        this.gameCtx.beginPath();
        
        const points = 8;
        for (let i = 0; i < points; i++) {
            const angle = (Math.PI * 2 * i) / points;
            const radius = asteroid.radius * (0.8 + Math.sin(i * 1.3) * 0.2);
            const x = Math.cos(angle) * radius;
            const y = Math.sin(angle) * radius;
            
            if (i === 0) {
                this.gameCtx.moveTo(x, y);
            } else {
                this.gameCtx.lineTo(x, y);
            }
        }
        
        this.gameCtx.closePath();
        this.gameCtx.stroke();
        this.gameCtx.restore();
    }
    
    drawParticles() {
        this.particles.forEach(particle => {
            const alpha = particle.life / particle.maxLife;
            this.gameCtx.globalAlpha = alpha;
            
            // Use particle color if available, otherwise default
            this.gameCtx.fillStyle = particle.color || ASTEROIDS.COLORS.GAME.PARTICLE;
            this.gameCtx.beginPath();
            const size = particle.size || 2;
            this.gameCtx.arc(particle.x, particle.y, size, 0, Math.PI * 2);
            this.gameCtx.fill();
        });
        this.gameCtx.globalAlpha = 1;
    }
    
    /**
     * Draw expanding nuke circle effect
     */
    drawNukeCircle() {
        const progress = this.nukeCircle.radius / this.nukeCircle.maxRadius;
        const alpha = 1 - progress; // Fade out as it expands
        
        this.gameCtx.save();
        this.gameCtx.globalAlpha = alpha * 0.8;
        
        // Outer bright circle
        this.gameCtx.strokeStyle = ASTEROIDS.COLORS.GAME.SHIP_THRUST;
        this.gameCtx.lineWidth = 6;
        this.gameCtx.beginPath();
        this.gameCtx.arc(this.nukeCircle.x, this.nukeCircle.y, this.nukeCircle.radius, 0, Math.PI * 2);
        this.gameCtx.stroke();
        
        // Inner energy circle
        this.gameCtx.globalAlpha = alpha * 0.3;
        this.gameCtx.fillStyle = ASTEROIDS.COLORS.GAME.SHIP_THRUST;
        this.gameCtx.beginPath();
        this.gameCtx.arc(this.nukeCircle.x, this.nukeCircle.y, this.nukeCircle.radius * 0.7, 0, Math.PI * 2);
        this.gameCtx.fill();
        
        this.gameCtx.restore();
    }
    
    /**
     * GUI Layer Rendering
     * 
     * ActionEngine's GUI layer renders above the game layer and is always 2D.
     * This layer is perfect for UI elements, HUD, menus, and overlays.
     */
    drawGUILayer() {
        this.guiCtx.clearRect(0, 0, ASTEROIDS.WIDTH, ASTEROIDS.HEIGHT);
        
        if (this.gameState === 'startScreen') {
            this.drawStartScreen();
        } else {
            this.drawHUD();
            this.drawWeaponPanel();
            this.drawNukeButton();
            
            if (this.gameState === 'gameOver') {
                this.drawGameOver();
            }
        }
    }
    
    drawHUD() {
        this.guiCtx.fillStyle = ASTEROIDS.COLORS.GUI.TEXT;
        this.guiCtx.font = '20px Arial';
        this.guiCtx.textAlign = 'left';
        
        this.guiCtx.fillText(`Score: ${this.score}`, ASTEROIDS.UI.HUD_MARGIN, 30);
        this.guiCtx.fillText(`Lives: ${this.lives}`, ASTEROIDS.UI.HUD_MARGIN, 55);
        this.guiCtx.fillText(`Level: ${this.level}`, ASTEROIDS.UI.HUD_MARGIN, 80);
    }
    
    drawWeaponPanel() {
        const panel = ASTEROIDS.UI.WEAPON_PANEL;
        
        // Panel background
        this.guiCtx.fillStyle = ASTEROIDS.COLORS.GUI.PANEL_BG;
        this.guiCtx.fillRect(panel.x, panel.y, panel.width, panel.height);
        
        // Title
        this.guiCtx.fillStyle = ASTEROIDS.COLORS.GUI.TEXT;
        this.guiCtx.font = '16px Arial';
        this.guiCtx.textAlign = 'left';
        this.guiCtx.fillText('Weapons', panel.x + 10, panel.y + 20);
        
        // Weapon buttons
        this.weaponButtons.forEach(button => {
            let bgColor;
            if (button.selected) {
                bgColor = ASTEROIDS.COLORS.GUI.BUTTON_ACTIVE;
            } else if (button.hovered) {
                bgColor = ASTEROIDS.COLORS.GUI.BUTTON_HOVER;
            } else {
                bgColor = ASTEROIDS.COLORS.GUI.BUTTON_IDLE;
            }
            
            this.guiCtx.fillStyle = bgColor;
            this.guiCtx.fillRect(button.x, button.y, button.width, button.height);
            
            this.guiCtx.strokeStyle = ASTEROIDS.COLORS.GUI.TEXT;
            this.guiCtx.lineWidth = 1;
            this.guiCtx.strokeRect(button.x, button.y, button.width, button.height);
            
            this.guiCtx.fillStyle = ASTEROIDS.COLORS.GUI.TEXT;
            this.guiCtx.font = '12px Arial';
            this.guiCtx.textAlign = 'center';
            this.guiCtx.fillText(button.name, button.x + button.width / 2, button.y + button.height / 2 + 3);
        });
    }
    
    drawNukeButton() {
        const button = this.nukeButton;
        
        let bgColor, textColor;
        if (button.enabled) {
            bgColor = button.hovered ? ASTEROIDS.COLORS.GUI.BUTTON_HOVER : ASTEROIDS.COLORS.GUI.BUTTON_ACTIVE;
            textColor = ASTEROIDS.COLORS.GUI.TEXT;
        } else {
            bgColor = ASTEROIDS.COLORS.GUI.BUTTON_DISABLED;
            textColor = '#666666';
        }
        
        this.guiCtx.fillStyle = bgColor;
        this.guiCtx.fillRect(button.x, button.y, button.width, button.height);
        
        this.guiCtx.strokeStyle = textColor;
        this.guiCtx.lineWidth = 2;
        this.guiCtx.strokeRect(button.x, button.y, button.width, button.height);
        
        this.guiCtx.fillStyle = textColor;
        this.guiCtx.font = 'bold 14px Arial';
        this.guiCtx.textAlign = 'center';
        this.guiCtx.fillText('NUKE', button.x + button.width / 2, button.y + button.height / 2 - 3);
        this.guiCtx.font = '10px Arial';
        this.guiCtx.fillText('(Right Click)', button.x + button.width / 2, button.y + button.height / 2 + 12);
        this.guiCtx.fillText(`${ASTEROIDS.GAMEPLAY.NUKE_COST} pts`, button.x + button.width / 2, button.y + button.height / 2 + 29);
    }
    
    drawInstructions() {
        this.guiCtx.fillStyle = '#888888';
        this.guiCtx.font = '14px Arial';
        this.guiCtx.textAlign = 'center';
        
        const instructions = [
            'Arrow Keys: Move  Action1: Fire  Action2: Mouse Aim',
            'Left Click: Fire  Right Click: Nuke  Middle Click: Cycle Weapon',
            'Click asteroids to destroy  F9: Debug overlay'
        ];
        
        instructions.forEach((instruction, i) => {
            this.guiCtx.fillText(instruction, ASTEROIDS.WIDTH / 2, ASTEROIDS.HEIGHT - 60 + i * 18);
        });
    }
    
    /**
     * Draw start screen with title and start button
     */
    drawStartScreen() {
        // Clear everything
        this.guiCtx.clearRect(0, 0, ASTEROIDS.WIDTH, ASTEROIDS.HEIGHT);
        
        // Title
        this.guiCtx.save();
        this.guiCtx.fillStyle = ASTEROIDS.COLORS.GUI.TEXT;
        this.guiCtx.font = 'bold 64px Arial';
        this.guiCtx.textAlign = 'center';
        this.guiCtx.textBaseline = 'middle';
        
        // Main title with shadow effect
        this.guiCtx.fillStyle = 'rgba(0, 0, 0, 0.5)';
        this.guiCtx.fillText('ASTEROIDS', ASTEROIDS.WIDTH / 2 + 3, ASTEROIDS.HEIGHT / 2 - 47);
        
        this.guiCtx.fillStyle = ASTEROIDS.COLORS.GAME.SHIP;
        this.guiCtx.fillText('ASTEROIDS', ASTEROIDS.WIDTH / 2, ASTEROIDS.HEIGHT / 2 - 50);
        
        // Subtitle
        this.guiCtx.fillStyle = ASTEROIDS.COLORS.GUI.TEXT;
        this.guiCtx.font = '20px Arial';
        this.guiCtx.fillText('ActionEngine Input System Demo', ASTEROIDS.WIDTH / 2, ASTEROIDS.HEIGHT / 2 - 10);
        
        this.guiCtx.restore();
        
        // Draw start button
        const button = this.startButton;
        
        // Button background with hover effect
        this.guiCtx.fillStyle = button.hovered ? ASTEROIDS.COLORS.GUI.BUTTON_HOVER : ASTEROIDS.COLORS.GUI.BUTTON_ACTIVE;
        this.guiCtx.fillRect(button.x, button.y, button.width, button.height);
        
        // Button border
        this.guiCtx.strokeStyle = ASTEROIDS.COLORS.GUI.TEXT;
        this.guiCtx.lineWidth = 3;
        this.guiCtx.strokeRect(button.x, button.y, button.width, button.height);
        
        // Button text
        this.guiCtx.fillStyle = ASTEROIDS.COLORS.GUI.TEXT;
        this.guiCtx.font = 'bold 24px Arial';
        this.guiCtx.textAlign = 'center';
        this.guiCtx.fillText('START GAME', button.x + button.width / 2, button.y + button.height / 2 + 8);
        
        // Instructions
        this.guiCtx.fillStyle = '#888888';
        this.guiCtx.font = '16px Arial';
        this.guiCtx.fillText('Click button or press Action1 to start', ASTEROIDS.WIDTH / 2, button.y + button.height + 40);
        
        // Demo info at top
        this.guiCtx.font = '16px Arial';
        this.guiCtx.fillStyle = '#aaaaaa';
        this.guiCtx.fillText('Comprehensive demonstration of ActionEngine\'s three-layer input system', ASTEROIDS.WIDTH / 2, 80);
        this.guiCtx.fillText('Featuring element registration, mouse buttons, and layer priority', ASTEROIDS.WIDTH / 2, 100);
        
        // Game instructions
        this.guiCtx.font = '14px Arial';
        this.guiCtx.fillStyle = '#888888';
        const instructions = [
            'Arrow Keys: Move  Action1: Fire  Action2: Mouse Aim',
            'Left Click: Fire  Right Click: Nuke  Middle Click: Cycle Weapon',
            'Click asteroids to destroy  ActionDebugToggle: Debug overlay'
        ];
        
        instructions.forEach((instruction, i) => {
            this.guiCtx.fillText(instruction, ASTEROIDS.WIDTH / 2, ASTEROIDS.HEIGHT - 80 + i * 18);
        });
    }
    
    drawGameOver() {
        this.guiCtx.fillStyle = 'rgba(0, 0, 0, 0.8)';
        this.guiCtx.fillRect(0, 0, ASTEROIDS.WIDTH, ASTEROIDS.HEIGHT);
        
        this.guiCtx.fillStyle = '#ff4444';
        this.guiCtx.font = 'bold 48px Arial';
        this.guiCtx.textAlign = 'center';
        this.guiCtx.fillText('GAME OVER', ASTEROIDS.WIDTH / 2, ASTEROIDS.HEIGHT / 2 - 50);
        
        this.guiCtx.fillStyle = ASTEROIDS.COLORS.GUI.TEXT;
        this.guiCtx.font = '24px Arial';
        this.guiCtx.fillText(`Final Score: ${this.score}`, ASTEROIDS.WIDTH / 2, ASTEROIDS.HEIGHT / 2);
        this.guiCtx.fillText(`Level Reached: ${this.level}`, ASTEROIDS.WIDTH / 2, ASTEROIDS.HEIGHT / 2 + 30);
        
        // Draw reset button
        const button = this.gameOverResetButton;
        
        // Button background with hover effect
        this.guiCtx.fillStyle = button.hovered ? ASTEROIDS.COLORS.GUI.BUTTON_HOVER : ASTEROIDS.COLORS.GUI.BUTTON_ACTIVE;
        this.guiCtx.fillRect(button.x, button.y, button.width, button.height);
        
        // Button border
        this.guiCtx.strokeStyle = ASTEROIDS.COLORS.GUI.TEXT;
        this.guiCtx.lineWidth = 3;
        this.guiCtx.strokeRect(button.x, button.y, button.width, button.height);
        
        // Button text
        this.guiCtx.fillStyle = ASTEROIDS.COLORS.GUI.TEXT;
        this.guiCtx.font = 'bold 20px Arial';
        this.guiCtx.fillText('RESTART GAME', button.x + button.width / 2, button.y + button.height / 2 + 7);
        
        // Instructions
        this.guiCtx.font = '16px Arial';
        this.guiCtx.fillStyle = '#888888';
        this.guiCtx.fillText('Click button or press Action1 to restart', ASTEROIDS.WIDTH / 2, ASTEROIDS.HEIGHT / 2 + 150);
    }
    
    /**
     * Debug Layer Rendering
     * 
     * ActionEngine's debug layer renders above all other layers.
     */
    drawDebugLayer() {
        // Always clear the debug canvas first
        this.debugCtx.clearRect(0, 0, ASTEROIDS.WIDTH, ASTEROIDS.HEIGHT);
        
        // Only draw content when debug overlay is visible
        if (!this.debugOverlayVisible) return;
        
        this.debugCtx.clearRect(0, 0, ASTEROIDS.WIDTH, ASTEROIDS.HEIGHT);
        
        // Debug panel background
        const panel = ASTEROIDS.UI.DEBUG_PANEL;
        this.debugCtx.fillStyle = ASTEROIDS.COLORS.DEBUG.BACKGROUND;
        this.debugCtx.fillRect(panel.x, panel.y, panel.width, panel.height);
        
        // Debug info
        if (this.debugInfoVisible) {
            this.debugCtx.fillStyle = ASTEROIDS.COLORS.DEBUG.TEXT;
            this.debugCtx.font = '14px monospace';
            this.debugCtx.textAlign = 'left';
            
            const debugInfo = [
                'ActionEngine Input System Debug',
                '',
                'THREE-LAYER INPUT PRIORITY:',
                '1. Debug Layer (this panel)',
                '2. GUI Layer (buttons, HUD)',
                '3. Game Layer (asteroids)',
                '',
                'REGISTERED ELEMENTS:',
                `- Nuke button: ${this.nukeButton.enabled ? 'enabled' : 'disabled'}`,
                `- Weapon buttons: ${this.weaponButtons.length}`,
                `- Asteroid elements: ${this.asteroidElements.length}`,
                '',
                'INPUT STATE:',
                `- Current weapon: ${this.currentWeapon.name}`,
                `- Fire timer: ${this.fireTimer.toFixed(2)}`,
                `- Bullets active: ${this.bullets.length}`,
                '',
                'GAME STATE:',
                `- Ship: ${this.ship ? 'Active' : 'Destroyed'}`,
                `- Asteroids: ${this.asteroids.length}`,
                `- Particles: ${this.particles.length}`,
                `- Frame: ${this.frameCount}`
            ];
            
            debugInfo.forEach((line, i) => {
                this.debugCtx.fillText(line, panel.x + 10, panel.y + 25 + i * 16);
            });
        }
        
        // Debug controls
        this.drawDebugControls();
    }
}
```

You can see that the "Asteroids" demo has shown the patterns and API for ActionEngine input and display, but it didn't really highlight the strengths of the audio capabilities.

To enhance your understanding of sound, ActionEngine provides the following documentation:

```actionengineaudiodocumentation
/*-----------------
* AUDIO INTEGRATION:
* -----------------
* Action Engine includes a powerful and flexible audio system for adding sound effects and music to your game.
*
* Sound in games is a critical part of the overall presentation, and it's often
* overlooked or pushed onto the back-burner due to a plethora of difficulties.
* The Action Engine audio system solves these common challenges with multiple synthesis methods:
*
* SYNTHESIS OPTIONS:
* - Basic Waveforms: Create simple tones using sine, triangle, and square waves
* - FM Synthesis: Generate rich, dynamic sounds through frequency modulation
* - Complex Synthesis: Layer multiple oscillators for full, harmonic sounds
* - Noise Generation: Create white, pink, or brown noise for effects
* - Frequency Sweeps: Create dramatic pitch slides and transitions
*
* MIDI CAPABILITIES:
* - Full 128-instrument library built-in
* - High quality sampled instruments from pianos to drums
* - Multi-channel playback support
* - No external sound files needed
*
* AUDIO CONTROL:
* - Real-time parameter control
* - Individual sound volume control (setSoundVolume)
* - Master volume control (setVolume)
* - Automatic sound stacking prevention
* - Sound completion callbacks (onEnd)
* - Flexible repeat and looping (repeat: number or -1 for infinite)
* - Stereo panning
* - Volume envelopes (ADSR)
* - Effects processing (reverb, echo, filters)
* - Complete playback control (play(), stopSound(), stopAllSounds())
*
* SEQUENCING:
* - SonicPi-style scripting for complex arrangements
* - Tempo and timing control
* - Multiple concurrent tracks
* - Effect chains and processing
*
* The DEMO maps various sounds to inputs to showcase these capabilities:
* - One-shot sound effects for edge-triggered actions
* - Different synthesis types for varied sound design
* - MIDI instrument playback
* - Complex musical arrangements
*
* Let's dive in and make some noise!
*/
```

To demonstrate these capabilities, ActionEngine provides a "Breakout" demo focused on sound creation and playback:

```breakoutdemo
/**
 * ActionEngine Audio System Demo
 * 
 * Welcome to the ActionEngine Audio System demonstration! This breakout game serves as a
 * comprehensive showcase of ActionEngine's sophisticated audio synthesis capabilities.
 * 
 * ActionEngine simplifies game audio by providing multiple synthesis types, MIDI integration,
 * and powerful sound management - all without requiring external audio files. This demo shows
 * you how to use every audio feature ActionEngine provides.
 * 
 * ACTIONENGINE AUDIO SYNTHESIS TYPES:
 * ActionEngine provides four main synthesis methods for creating dynamic game audio:
 * 
 * 1. SWEEP SOUNDS - Frequency sweeps from start to end frequency
 * 
 * 2. COMPLEX SOUNDS - Multiple oscillators layered together
 * 
 * 3. FM SYNTHESIS - Frequency modulation for rich, dynamic timbres
 * 
 * 4. NOISE SYNTHESIS - Filtered noise for natural/percussive sounds
 * 
 * 5. MIDI INTEGRATION - High-quality sampled instruments
 * 
 * ACTIONENGINE AUDIO FEATURES:
 * - Automatic sound stacking prevention
 * - Individual volume control per sound
 * - Sound completion callbacks (onEnd)
 * - Flexible repeat and looping systems
 * - Real-time parameter control
 * - Master volume management
 */

/******* GAME CONFIGURATION CONSTANTS *******/
const BREAKOUT = {
    // ActionEngine requires these exact dimensions
    WIDTH: 800,
    HEIGHT: 600,
    
    // Game physics
    PHYSICS: {
        PADDLE_SPEED: 400,
        BALL_SPEED: 250,
        BALL_SPEED_INCREASE: 1.02,
        MAX_BALL_SPEED: 450,
        BOUNCE_RANDOMNESS: 0.1
    },
    
    // Visual configuration
    VISUAL: {
        PADDLE_WIDTH: 120,
        PADDLE_HEIGHT: 20,
        BALL_RADIUS: 8,
        BRICK_WIDTH: 70,
        BRICK_HEIGHT: 32,
        BRICK_PADDING: 4,
        PARTICLE_COUNT: 8,
        TRAIL_LENGTH: 6
    },
    
    // Three-layer color scheme with gradients
    COLORS: {
        GAME: {
            BACKGROUND: '#0f0f23',
            PADDLE: '#00d4ff',
            PADDLE_GLOW: '#0088cc',
            BALL: '#ffffff',
            BALL_TRAIL: '#66ddff',
            PARTICLE: '#ff6b35',
            
            // Brick colors for different audio frequencies
            BRICKS: {
                TOP: '#ff6b6b',      // High frequency - red
                UPPER: '#4ecdc4',    // Medium-high - teal  
                MIDDLE: '#45b7d1',   // Medium - blue
                LOWER: '#96ceb4',    // Medium-low - green
                BOTTOM: '#ffeaa7'    // Low frequency - yellow
            }
        },
        GUI: {
            TEXT: '#ffffff',
            PANEL_BG: 'rgba(15, 15, 35, 0.9)',
            BUTTON_IDLE: '#2d3748',
            BUTTON_HOVER: '#4a5568',
            BUTTON_ACTIVE: '#00d4ff',
            HUD_BG: 'rgba(0, 0, 0, 0.6)'
        },
        DEBUG: {
            BACKGROUND: 'rgba(0, 30, 0, 0.85)',
            TEXT: '#00ff41',
            HIGHLIGHT: '#ffff00',
            WARNING: '#ff6b6b'
        }
    },
    
    // Gameplay constants
    GAMEPLAY: {
        STARTING_LIVES: 3,
        BRICK_ROWS: 5,
        BRICK_COLS: 10,
        POINTS_PER_BRICK: 10,
        LEVEL_COMPLETE_BONUS: 1000,
        BALL_RESPAWN_TIME: 2.0
    },
    
    // Audio configuration - real ActionEngine features only
    AUDIO: {
        MASTER_VOLUME: 0.7,
        EFFECT_VOLUME: 0.8,
        MUSIC_VOLUME: 0.5,
        
        // Frequency ranges for different game elements
        FREQUENCIES: {
            PADDLE_HIT: { start: 220, end: 440 },
            WALL_BOUNCE: { start: 440, end: 880 },
            BRICK_BREAK: [262, 330, 392], // C major chord
            POWER_UP: [440, 554, 659, 880], // A major arpeggio
            BALL_LOST: { noise: 'brown', filter: 200 },
            VICTORY: [523, 659, 784, 1047] // C major scale up
        }
    },
    
    // UI layout for different layers
    UI: {
        HUD_MARGIN: 20,
        AUDIO_PANEL: { x: 520, y: 20, width: 260, height: 200 },
        DEBUG_PANEL: { x: 50, y: 80, width: 400, height: 420 },
        RESTART_BUTTON: { x: 300, y: 350, width: 200, height: 60 }
    }
};

/**
 * ActionEngine Game Class
 */
class Game {
    /******* ActionEngine Required Constants *******/
    static WIDTH = BREAKOUT.WIDTH;
    static HEIGHT = BREAKOUT.HEIGHT;
    
    /**
     * ActionEngine Game Constructor
     */
    constructor(canvases, input, audio) {
        /******* ActionEngine System References *******/
        this.input = input;
        this.audio = audio;
        
        /******* ActionEngine Three-Layer Canvas System *******/
        
        // Game layer: Your main content (2D context for this demo)
        this.gameCanvas = canvases.gameCanvas;
        this.gameCtx = this.gameCanvas.getContext('2d');
        this.guiCanvas = canvases.guiCanvas;
        this.guiCtx = canvases.guiCtx;
        this.debugCanvas = canvases.debugCanvas;
        this.debugCtx = canvases.debugCtx;
        
        /******* Game State *******/
        this.gameState = 'startScreen'; // 'startScreen' | 'playing' | 'gameOver' | 'victory' | 'ballLost'
        this.score = 0;
        this.lives = BREAKOUT.GAMEPLAY.STARTING_LIVES;
        this.level = 1;
        this.ballRespawnTimer = 0;
        this.frameCount = 0;
        this.lastTime = performance.now();
        
        /******* Debug State *******/
        this.debugOverlayVisible = false;
        
        /******* Audio State Tracking *******/
        // Track sound events for educational debug info
        this.soundHistory = [];
        this.maxSoundHistory = 10;
        
        /******* Game Objects *******/
        this.paddle = null;
        this.ball = null;
        this.bricks = [];
        this.particles = [];
        
        /******* Visual Effects *******/
        this.screenFlash = 0;
        this.audioVisualizer = {
            paddleGlow: 0,
            brickGlow: new Map(),
            ballGlow: 0
        };
        
        /******* Enhanced Graphics State *******/
        this.energyWaves = this.createEnergyWaves();
        this.animationTime = 0;

        this.levelTransition = { active: false, progress: 0 };
        
        /******* ActionEngine Audio System Setup *******/
        // This is the core focus of this demo - comprehensive audio integration
        this.setupComprehensiveAudioSystem();
        
        /******* Input Integration *******/
        this.setupInputSystem();
        
        /******* Initialize Game Content *******/
        // Game objects will be created when game starts
        
        console.log('ActionEngine Audio Demo Ready!');
        console.log('Demonstrating all synthesis types and enhanced 2D graphics');
    }
    
    /******* COMPREHENSIVE ACTIONENGINE AUDIO DEMONSTRATION *******/
    
    /**
     * Complete ActionEngine Audio System Setup
     * 
     * This method demonstrates every audio synthesis type ActionEngine provides.
     * Unlike external audio files, ActionEngine generates all sounds programmatically,
     * giving you complete control over every parameter and ensuring small file sizes.
     * 
     * ActionEngine's audio system is built on the Web Audio API but abstracts away
     * all the complexity, providing simple methods for complex sound synthesis.
     */
    setupComprehensiveAudioSystem() {
        /******* 1. SWEEP SOUND SYNTHESIS *******/
        // ActionEngine's createSweepSound() creates frequency sweeps
        // Perfect for movement, UI feedback, and projectile sounds
        
        // Paddle hit - classic arcade sweep with triangle wave
        this.audio.createSweepSound('paddle_hit', {
            startFreq: BREAKOUT.AUDIO.FREQUENCIES.PADDLE_HIT.start,
            endFreq: BREAKOUT.AUDIO.FREQUENCIES.PADDLE_HIT.end,
            type: 'triangle', // Options: 'sine', 'square', 'sawtooth', 'triangle'
            duration: 0.2,
            envelope: {
                attack: 0.01,  // How quickly sound starts
                decay: 0.05,   // How quickly it drops from peak
                sustain: 0.3,  // Level to sustain at (0-1)
                release: 0.14  // How quickly it fades to silence
            }
        });
        
        // Wall bounce - higher pitched ping
        this.audio.createSweepSound('wall_bounce', {
            startFreq: BREAKOUT.AUDIO.FREQUENCIES.WALL_BOUNCE.start,
            endFreq: BREAKOUT.AUDIO.FREQUENCIES.WALL_BOUNCE.end,
            type: 'sine',
            duration: 0.15,
            envelope: {
                attack: 0.01,
                decay: 0.14,
                sustain: 0,
                release: 0
            }
        });
        
        // Ball launch - dramatic upward sweep
        this.audio.createSweepSound('ball_launch', {
            startFreq: 200,
            endFreq: 800,
            type: 'sawtooth',
            duration: 0.4,
            envelope: {
                attack: 0.02,
                decay: 0.1,
                sustain: 0.6,
                release: 0.28
            }
        });
        
        /******* 2. COMPLEX SOUND SYNTHESIS *******/
        // ActionEngine's createComplexSound() layers multiple oscillators
        // Perfect for rich, harmonic sounds and chord-like effects
        
        // Brick break - harmonic chord based on brick position
        this.audio.createComplexSound('brick_break', {
            frequencies: BREAKOUT.AUDIO.FREQUENCIES.BRICK_BREAK, // C major chord
            types: ['sine', 'triangle', 'sine'], // Different wave types per oscillator
            mix: [0.4, 0.4, 0.2], // Volume mix for each oscillator
            duration: 0.3,
            envelope: {
                attack: 0.01,
                decay: 0.1,
                sustain: 0.2,
                release: 0.19
            }
        });
        
        // Power-up style sound with ascending harmonies
        this.audio.createComplexSound('level_complete', {
            frequencies: BREAKOUT.AUDIO.FREQUENCIES.POWER_UP,
            types: ['sine', 'triangle', 'sine', 'triangle'],
            mix: [0.3, 0.3, 0.2, 0.2],
            duration: 0.8,
            envelope: {
                attack: 0.05,
                decay: 0.2,
                sustain: 0.4,
                release: 0.55
            }
        });
        
        // Victory fanfare - ascending major scale
        this.audio.createComplexSound('victory', {
            frequencies: BREAKOUT.AUDIO.FREQUENCIES.VICTORY,
            types: ['sine', 'sine', 'sine', 'sine'],
            mix: [0.3, 0.25, 0.25, 0.2],
            duration: 1.2,
            envelope: {
                attack: 0.1,
                decay: 0.3,
                sustain: 0.5,
                release: 0.8
            }
        });
        
        /******* 3. FM SYNTHESIS *******/
        // ActionEngine's createFMSound() uses frequency modulation
        // Perfect for metallic, bell-like, and evolving sounds
        
        // Special brick sound - metallic FM bell
        this.audio.createFMSound('special_brick', {
            carrierFreq: 660,    // Base frequency
            modulatorFreq: 330,  // Modulating frequency (half of carrier)
            modulationIndex: 80, // How intense the modulation is
            type: 'sine',
            duration: 0.5,
            envelope: {
                attack: 0.02,
                decay: 0.15,
                sustain: 0.3,
                release: 0.33
            }
        });
        
        // Game over sound - deep, evolving FM
        this.audio.createFMSound('game_over', {
            carrierFreq: 110,
            modulatorFreq: 55,
            modulationIndex: 120,
            type: 'triangle',
            duration: 1.5,
            envelope: {
                attack: 0.1,
                decay: 0.4,
                sustain: 0.6,
                release: 1.0
            }
        });
        
        /******* 4. NOISE SYNTHESIS *******/
        // ActionEngine's createNoiseSound() generates filtered noise
        // Perfect for percussion, explosions, and natural textures
        
        // Ball lost - dramatic brown noise crash
        this.audio.createNoiseSound('ball_lost', {
            noiseType: 'brown', // Options: 'white', 'pink', 'brown'
            duration: 0.6,
            envelope: {
                attack: 0.01,
                decay: 0.2,
                sustain: 0.2,
                release: 0.39
            },
            filterOptions: {
                frequency: BREAKOUT.AUDIO.FREQUENCIES.BALL_LOST.filter,
                Q: 2,        // Filter resonance
                type: 'lowpass' // Filter type
            }
        });
        
        // Explosion particle effect
        this.audio.createNoiseSound('explosion', {
            noiseType: 'white',
            duration: 0.4,
            envelope: {
                attack: 0.01,
                decay: 0.1,
                sustain: 0.1,
                release: 0.29
            },
            filterOptions: {
                frequency: 800,
                Q: 1.5,
                type: 'bandpass'
            }
        });
        
        /******* 5. MIDI INTEGRATION *******/
        // ActionEngine's createSound() with SonicPi scripting provides MIDI instruments
        // This gives you access to high-quality sampled instruments
        
        // Victory music with full MIDI orchestra
        this.audio.createSound('victory_music', {
            script: `
                use_bpm 120
                
                sample :trumpet, note: 72, amp: 0.5
                sample :strings, note: 60, amp: 0.3, duration: 3
                sleep 0.5
                sample :trumpet, note: 76, amp: 0.5
                sample :strings, note: 64, amp: 0.3, duration: 2.5
                sleep 0.5
                sample :trumpet, note: 79, amp: 0.6
                sample :timpani, note: 48, amp: 0.4
                sleep 0.5
                sample :trumpet, note: 84, amp: 0.7, duration: 2
                sample :strings, note: 67, amp: 0.4, duration: 2
            `,
            samples: {
                'trumpet': {
                    soundType: 'midi',
                    instrument: 'trumpet',
                    amp: 0.5
                },
                'strings': {
                    soundType: 'midi', 
                    instrument: 'string_ensemble_1',
                    amp: 0.3
                },
                'timpani': {
                    soundType: 'midi',
                    instrument: 'timpani',
                    amp: 0.4
                }
            }
        }, 'sonicpi');
        
        /******* ACTIONENGINE AUDIO MANAGEMENT FEATURES *******/
        
        // Set master volume - affects all sounds
        this.audio.setVolume(BREAKOUT.AUDIO.MASTER_VOLUME);
        
        console.log('ActionEngine Audio: All synthesis types configured');
        console.log('Available: Sweep, Complex, FM, Noise, and MIDI synthesis');
    }
    
    /******* AUDIO-DRIVEN GAMEPLAY FEATURES *******/
    /**
     * Play sound with enhanced feedback
     * Demonstrates ActionEngine's callback system and automatic stacking prevention
     */
    playSound(soundName, options = {}) {
        // ActionEngine automatically prevents sound stacking - multiple calls to play
        // the same sound won't create overlapping instances
        
        const defaultOptions = {
            volume: BREAKOUT.AUDIO.EFFECT_VOLUME,
            onEnd: () => {
                this.logSoundEvent(`${soundName} completed`);
            }
        };
        
        const finalOptions = { ...defaultOptions, ...options };
        
        this.audio.play(soundName, finalOptions);
        this.logSoundEvent(`Playing: ${soundName}`);
        
        // Update visual feedback based on sound
        this.updateAudioVisualization(soundName);
    }
    
    /**
     * Log sound events for educational debug display
     */
    logSoundEvent(event) {
        const timestamp = new Date().toLocaleTimeString();
        this.soundHistory.unshift(`[${timestamp}] ${event}`);
        
        // Keep history manageable
        if (this.soundHistory.length > this.maxSoundHistory) {
            this.soundHistory.pop();
        }
    }
    
    /**
     * Update visual effects based on audio events
     * Creates audio-reactive graphics
     */
    updateAudioVisualization(soundName) {
        switch (soundName) {
            case 'paddle_hit':
                this.audioVisualizer.paddleGlow = 1.0;
                break;
            case 'brick_break':
            case 'special_brick':
                this.audioVisualizer.ballGlow = 0.8;
                break;
            case 'wall_bounce':
                this.audioVisualizer.ballGlow = 0.6;
                break;
        }
    }
    
    /******* INPUT SYSTEM SETUP *******/
    
    /**
     * Input setup including start screen button
     * This demo focuses on audio, so input is simpler than asteroids demo
     */
    setupInputSystem() {
        // Start button for initial screen
        this.startButton = {
            x: BREAKOUT.WIDTH / 2 - 120,
            y: BREAKOUT.HEIGHT / 2 + 50,
            width: 240,
            height: 60,
            hovered: false
        };
        
        // Register start button with input system
        this.input.registerElement('start_button', {
            bounds: () => ({
                x: this.startButton.x,
                y: this.startButton.y,
                width: this.startButton.width,
                height: this.startButton.height
            })
        });
        
        console.log('Input system ready - start screen and game controls');
    }
    
    /******* ACTIONENGINE FRAMEWORK HOOKS *******/
    
    /**
     * action_update() - ActionEngine Framework Hook
     */
    action_update() {
        // Calculate delta time for smooth movement
        const currentTime = performance.now();
        const deltaTime = Math.min((currentTime - this.lastTime) / 1000, 0.25);
        this.lastTime = currentTime;
        this.frameCount++;
        
        // Main update logic
        this.handleInput(deltaTime);
        this.updateGameObjects(deltaTime);
        this.updateTimers(deltaTime);
        
        if (this.gameState === 'playing') {
            this.checkCollisions();
            this.checkLevelComplete();
        }
        
        this.updateVisualEffects(deltaTime);
    }
    
    /**
     * action_draw() - ActionEngine Framework Hook
     */
    action_draw() {
        // Render across ActionEngine's three-layer system
        this.drawGameLayer();
        this.drawGUILayer();
        this.drawDebugLayer();
    }
    
    /******* INPUT HANDLING *******/
    
    handleInput(deltaTime) {
        // Handle debug toggle (works in all game states)
        if (this.input.isKeyJustPressed('ActionDebugToggle')) {
            this.debugOverlayVisible = !this.debugOverlayVisible;
            this.logSoundEvent(`Debug overlay ${this.debugOverlayVisible ? 'shown' : 'hidden'}`);
        }
        
        // Route input based on game state
        if (this.gameState === 'startScreen') {
            this.handleStartScreenInput();
        } else if (this.gameState === 'playing') {
            this.handleGameplayInput(deltaTime);
        } else if (this.gameState === 'gameOver' || this.gameState === 'victory') {
            this.handleGameOverInput();
        }
    }
    
    handleStartScreenInput() {
        // Check start button
        this.startButton.hovered = this.input.isElementHovered('start_button');
        
        if (this.input.isElementJustPressed('start_button') || this.input.isKeyJustPressed('Action1')) {
            this.startGame();
        }
    }
    
    handleGameplayInput(deltaTime) {
        // Only handle input if game objects exist
        if (!this.ball || !this.paddle) return;
        
        // Simple paddle control
        let paddleInput = 0;
        if (this.input.isKeyPressed('DirLeft')) paddleInput -= 1;
        if (this.input.isKeyPressed('DirRight')) paddleInput += 1;
        
        this.paddle.vx = paddleInput * BREAKOUT.PHYSICS.PADDLE_SPEED;
        this.paddle.x += this.paddle.vx * deltaTime;
        
        // Clamp paddle to screen
        this.paddle.x = Math.max(0, Math.min(BREAKOUT.WIDTH - this.paddle.width, this.paddle.x));
        
        // Ball launch
        if (this.ball.stuck && this.input.isKeyJustPressed('Action1')) {
            this.launchBall();
        }
        
        // Game state controls
        if (this.input.isKeyJustPressed('Action2')) {
            // Demonstrate volume control
            const currentVolume = this.audio.getVolume ? this.audio.getVolume() : BREAKOUT.AUDIO.MASTER_VOLUME;
            const newVolume = currentVolume > 0.5 ? 0.3 : 0.8;
            this.audio.setVolume(newVolume);
            this.logSoundEvent(`Volume changed to ${Math.round(newVolume * 100)}%`);
        }
        
        if (this.input.isKeyJustPressed('Action3')) {
            // Demonstrate stopping all sounds
            this.audio.stopAllSounds();
            this.logSoundEvent('All sounds stopped');
        }
    }
    
    handleGameOverInput() {
        if (this.input.isKeyJustPressed('Action1')) {
            this.resetGame();
        }
    }
    
    launchBall() {
        this.ball.stuck = false;
        this.ball.vx = BREAKOUT.PHYSICS.BALL_SPEED * (Math.random() - 0.5) * 1.5;
        this.ball.vy = -BREAKOUT.PHYSICS.BALL_SPEED;
        
        // Demonstrate sound with callback
        this.playSound('ball_launch', {
            onEnd: () => {
                console.log('Ball launch sound completed - ball is in play!');
            }
        });
    }
    
    /******* GRAPHICS UTILITIES *******/
    
    /**
     * Create animated energy wave background
     */
    createEnergyWaves() {
        const waves = [];
        
        // Create flowing energy streams
        for (let i = 0; i < 8; i++) {
            waves.push({
                x: Math.random() * BREAKOUT.WIDTH,
                y: -50,
                amplitude: Math.random() * 30 + 20,
                frequency: Math.random() * 0.02 + 0.01,
                speed: Math.random() * 40 + 20,
                phase: Math.random() * Math.PI * 2,
                width: Math.random() * 3 + 2,
                color: `hsl(${180 + Math.random() * 60}, 70%, ${30 + Math.random() * 20}%)`,
                opacity: Math.random() * 0.4 + 0.1
            });
        }
        
        // Add some geometric elements
        for (let i = 0; i < 12; i++) {
            waves.push({
                type: 'circle',
                x: Math.random() * BREAKOUT.WIDTH,
                y: Math.random() * BREAKOUT.HEIGHT,
                radius: Math.random() * 20 + 5,
                speed: Math.random() * 15 + 5,
                opacity: Math.random() * 0.1 + 0.05,
                rotation: 0,
                rotationSpeed: (Math.random() - 0.5) * 2,
                pulsePhase: Math.random() * Math.PI * 2,
                color: `hsl(${200 + Math.random() * 40}, 60%, 40%)`
            });
        }
        
        return waves;
    }
    
    /**
     * Draw rounded rectangle utility
     */
    drawRoundedRect(ctx, x, y, width, height, radius) {
        ctx.beginPath();
        ctx.roundRect(x, y, width, height, radius);
    }
    
    /**
     * Create enhanced brick particles with rotation and color
     */
    createEnhancedBrickParticles(brick) {
        const particleCount = BREAKOUT.VISUAL.PARTICLE_COUNT + 4; // More particles
        
        for (let i = 0; i < particleCount; i++) {
            const angle = (Math.PI * 2 * i) / particleCount + Math.random() * 0.5;
            const speed = Math.random() * 200 + 100;
            const size = Math.random() * 4 + 2;
            
            this.particles.push({
                x: brick.x + brick.width / 2,
                y: brick.y + brick.height / 2,
                vx: Math.cos(angle) * speed,
                vy: Math.sin(angle) * speed - 50, // Upward bias
                life: Math.random() * 0.8 + 0.6,
                maxLife: 1.4,
                color: brick.color,
                size: size,
                rotation: 0,
                rotationSpeed: (Math.random() - 0.5) * 10
            });
        }
    }
    

    
    /******* GAME LOGIC *******/
    
    createPaddle() {
        this.paddle = {
            x: BREAKOUT.WIDTH / 2 - BREAKOUT.VISUAL.PADDLE_WIDTH / 2,
            y: BREAKOUT.HEIGHT - 60,
            width: BREAKOUT.VISUAL.PADDLE_WIDTH,
            height: BREAKOUT.VISUAL.PADDLE_HEIGHT,
            vx: 0
        };
    }
    
    createBall() {
        this.ball = {
            x: BREAKOUT.WIDTH / 2,
            y: BREAKOUT.HEIGHT / 2,
            vx: 0,
            vy: 0,
            trail: [],
            stuck: true  // Ball starts stuck to paddle
        };
    }
    
    createBrickField() {
        this.bricks = [];
        const colors = Object.values(BREAKOUT.COLORS.GAME.BRICKS);
        
        // Calculate centered brick field positioning
        const totalBrickWidth = (BREAKOUT.GAMEPLAY.BRICK_COLS * BREAKOUT.VISUAL.BRICK_WIDTH) + 
                               ((BREAKOUT.GAMEPLAY.BRICK_COLS - 1) * BREAKOUT.VISUAL.BRICK_PADDING);
        const startX = (BREAKOUT.WIDTH - totalBrickWidth) / 2;
        
        for (let row = 0; row < BREAKOUT.GAMEPLAY.BRICK_ROWS; row++) {
            for (let col = 0; col < BREAKOUT.GAMEPLAY.BRICK_COLS; col++) {
                this.bricks.push({
                    x: startX + col * (BREAKOUT.VISUAL.BRICK_WIDTH + BREAKOUT.VISUAL.BRICK_PADDING),
                    y: row * (BREAKOUT.VISUAL.BRICK_HEIGHT + BREAKOUT.VISUAL.BRICK_PADDING) + 80,
                    width: BREAKOUT.VISUAL.BRICK_WIDTH,
                    height: BREAKOUT.VISUAL.BRICK_HEIGHT,
                    color: colors[row % colors.length],
                    row: row,
                    destroyed: false
                });
            }
        }
    }
    
    updateGameObjects(deltaTime) {
        // Only update if game objects exist
        if (!this.ball || !this.paddle) return;
        
        // Update ball
        if (!this.ball.stuck) {
            this.ball.x += this.ball.vx * deltaTime;
            this.ball.y += this.ball.vy * deltaTime;
            
            // Update ball trail
            this.ball.trail.push({ x: this.ball.x, y: this.ball.y });
            if (this.ball.trail.length > BREAKOUT.VISUAL.TRAIL_LENGTH) {
                this.ball.trail.shift();
            }
        } else {
            // Ball follows paddle when stuck
            this.ball.x = this.paddle.x + this.paddle.width / 2;
            this.ball.y = this.paddle.y - BREAKOUT.VISUAL.BALL_RADIUS * 2;
        }
    }
    
    updateTimers(deltaTime) {
        this.ballRespawnTimer = Math.max(0, this.ballRespawnTimer - deltaTime);
        
        // Respawn ball if needed
        if (this.ballRespawnTimer === 0 && this.gameState === 'ballLost') {
            this.respawnBall();
        }
    }
    
    updateVisualEffects(deltaTime) {
        this.animationTime += deltaTime;
        
        // Update enhanced particles
        for (let i = this.particles.length - 1; i >= 0; i--) {
            const particle = this.particles[i];
            particle.x += particle.vx * deltaTime;
            particle.y += particle.vy * deltaTime;
            particle.vx *= 0.98; // Air resistance
            particle.vy += 200 * deltaTime; // Gravity
            particle.life -= deltaTime;
            particle.rotation += particle.rotationSpeed * deltaTime;
            
            if (particle.life <= 0) {
                this.particles.splice(i, 1);
            }
        }
        
        // Update animated energy waves
        this.energyWaves.forEach(wave => {
            if (wave.type === 'circle') {
                // Floating geometric elements
                wave.y -= wave.speed * deltaTime;
                wave.rotation += wave.rotationSpeed * deltaTime;
                wave.pulsePhase += deltaTime * 3;
                
                if (wave.y < -wave.radius * 2) {
                    wave.y = BREAKOUT.HEIGHT + wave.radius * 2;
                    wave.x = Math.random() * BREAKOUT.WIDTH;
                }
            } else {
                // Flowing energy streams
                wave.y += wave.speed * deltaTime;
                wave.phase += deltaTime * 2;
                
                if (wave.y > BREAKOUT.HEIGHT + 50) {
                    wave.y = -50;
                    wave.x = Math.random() * BREAKOUT.WIDTH;
                }
            }
        });
        

        
        // Update screen flash
        if (this.screenFlash > 0) {
            this.screenFlash -= deltaTime * 3;
            if (this.screenFlash < 0) this.screenFlash = 0;
        }
        
        // Update audio visualization glows
        this.audioVisualizer.paddleGlow *= 0.95;
        this.audioVisualizer.ballGlow *= 0.95;
        
        // Update level transition
        if (this.levelTransition.active) {
            this.levelTransition.progress += deltaTime * 2;
            if (this.levelTransition.progress >= 1) {
                this.levelTransition.active = false;
                this.levelTransition.progress = 0;
            }
        }
    }
    
    /******* COLLISION DETECTION WITH AUDIO *******/
    
    checkCollisions() {
        if (!this.ball || !this.paddle || this.ball.stuck) return;
        
        // Ball-paddle collision
        if (this.checkBallPaddleCollision()) {
            this.handlePaddleHit();
        }
        
        // Ball-brick collisions
        this.checkBallBrickCollisions();
        
        // Ball-wall collisions
        this.checkBallWallCollisions();
        
        // Ball lost
        if (this.ball.y > BREAKOUT.HEIGHT + 50) {
            this.handleBallLost();
        }
    }
    
    checkBallPaddleCollision() {
        return this.ball.x + BREAKOUT.VISUAL.BALL_RADIUS > this.paddle.x &&
               this.ball.x - BREAKOUT.VISUAL.BALL_RADIUS < this.paddle.x + this.paddle.width &&
               this.ball.y + BREAKOUT.VISUAL.BALL_RADIUS > this.paddle.y &&
               this.ball.y - BREAKOUT.VISUAL.BALL_RADIUS < this.paddle.y + this.paddle.height &&
               this.ball.vy > 0;
    }
    
    handlePaddleHit() {
        // Calculate hit position for angle variation
        const hitPos = (this.ball.x - this.paddle.x) / this.paddle.width;
        const angle = (hitPos - 0.5) * Math.PI / 3; // Max 60 degree angle
        
        const speed = Math.sqrt(this.ball.vx * this.ball.vx + this.ball.vy * this.ball.vy);
        this.ball.vx = Math.sin(angle) * speed;
        this.ball.vy = -Math.abs(Math.cos(angle) * speed);
        
        // Play paddle hit sound
        this.playSound('paddle_hit');
    }
    
    checkBallBrickCollisions() {
        for (let i = this.bricks.length - 1; i >= 0; i--) {
            const brick = this.bricks[i];
            if (brick.destroyed) continue;
            
            if (this.ball.x + BREAKOUT.VISUAL.BALL_RADIUS > brick.x &&
                this.ball.x - BREAKOUT.VISUAL.BALL_RADIUS < brick.x + brick.width &&
                this.ball.y + BREAKOUT.VISUAL.BALL_RADIUS > brick.y &&
                this.ball.y - BREAKOUT.VISUAL.BALL_RADIUS < brick.y + brick.height) {
                
                this.handleBrickHit(brick, i);
                break;
            }
        }
    }
    
    handleBrickHit(brick, index) {
        brick.destroyed = true;
        this.score += BREAKOUT.GAMEPLAY.POINTS_PER_BRICK;
        
        // Reverse ball direction
        this.ball.vy *= -1;
        
        // Add some randomness to prevent infinite loops
        this.ball.vx += (Math.random() - 0.5) * BREAKOUT.PHYSICS.BOUNCE_RANDOMNESS;
        
        // Play appropriate sound based on brick type
        if (brick.row === 0) {
            // Top row gets special FM sound
            this.playSound('special_brick');
        } else {
            // Regular brick break sound
            this.playSound('brick_break');
        }
        
        // Create enhanced particles
        this.createEnhancedBrickParticles(brick);
        
        // Slightly increase ball speed
        const speed = Math.sqrt(this.ball.vx * this.ball.vx + this.ball.vy * this.ball.vy);
        if (speed < BREAKOUT.PHYSICS.MAX_BALL_SPEED) {
            this.ball.vx *= BREAKOUT.PHYSICS.BALL_SPEED_INCREASE;
            this.ball.vy *= BREAKOUT.PHYSICS.BALL_SPEED_INCREASE;
        }
    }
    
    checkBallWallCollisions() {
        // Left/right walls
        if (this.ball.x <= BREAKOUT.VISUAL.BALL_RADIUS || 
            this.ball.x >= BREAKOUT.WIDTH - BREAKOUT.VISUAL.BALL_RADIUS) {
            this.ball.vx *= -1;
            this.ball.x = Math.max(BREAKOUT.VISUAL.BALL_RADIUS, 
                          Math.min(BREAKOUT.WIDTH - BREAKOUT.VISUAL.BALL_RADIUS, this.ball.x));
            
            this.playSound('wall_bounce');
        }
        
        // Top wall
        if (this.ball.y <= BREAKOUT.VISUAL.BALL_RADIUS) {
            this.ball.vy *= -1;
            this.ball.y = BREAKOUT.VISUAL.BALL_RADIUS;
            
            this.playSound('wall_bounce');
        }
    }
    
    handleBallLost() {
        this.lives--;
        this.gameState = 'ballLost';
        this.ballRespawnTimer = BREAKOUT.GAMEPLAY.BALL_RESPAWN_TIME;
        
        // Play dramatic ball lost sound
        this.playSound('ball_lost', {
            onEnd: () => {
                if (this.lives <= 0) {
                    this.gameState = 'gameOver';
                    this.handleGameOver();
                }
            }
        });
        
        this.screenFlash = 0.4;
    }
    
    handleGameOver() {
        // Play game over sound
        this.playSound('game_over');
    }
    
    respawnBall() {
        if (!this.paddle) return;
        
        this.ball.x = this.paddle.x + this.paddle.width / 2;
        this.ball.y = this.paddle.y - BREAKOUT.VISUAL.BALL_RADIUS * 2;
        this.ball.vx = 0;
        this.ball.vy = 0;
        this.ball.stuck = true;
        this.ball.trail = [];
        this.gameState = 'playing';
    }
    
    checkLevelComplete() {
        const remainingBricks = this.bricks.filter(brick => !brick.destroyed).length;
        
        if (remainingBricks === 0) {
            this.handleLevelComplete();
        }
    }
    
    handleLevelComplete() {
        this.score += BREAKOUT.GAMEPLAY.LEVEL_COMPLETE_BONUS;
        this.level++;
        this.gameState = 'victory';
        
        // Play victory sounds
        this.playSound('level_complete');
        
        setTimeout(() => {
            this.playSound('victory_music');
        }, 500);
    }
    
    startGame() {
        this.gameState = 'playing';
        this.score = 0;
        this.lives = BREAKOUT.GAMEPLAY.STARTING_LIVES;
        this.level = 1;
        
        // Create game objects
        this.createPaddle();
        this.createBall();
        this.createBrickField();
        this.particles = [];
        this.screenFlash = 0;
        
        this.logSoundEvent('Game started!');
    }
    
    resetGame() {
        this.gameState = 'playing';
        this.score = 0;
        this.lives = BREAKOUT.GAMEPLAY.STARTING_LIVES;
        this.level = 1;
        
        this.createBrickField();
        this.respawnBall();
        this.particles = [];
        this.screenFlash = 0;
        
        this.logSoundEvent('Game reset!');
    }
    
    /******* VISUAL EFFECTS *******/

    /******* ACTIONENGINE THREE-LAYER RENDERING *******/
    
    /**
     * Game Layer Rendering
     * 
     * This layer showcases filled graphics and visual effects,
     * different from the wireframe style used in the asteroids demo.
     */
    drawGameLayer() {
        // Clear with gradient background
        this.drawGradientBackground();
        
        // Only draw game objects when not on start screen
        if (this.gameState !== 'startScreen') {
            this.drawGameObjects();
        }
        
        this.drawParticles();
        
        // Screen flash effect (over everything)
        if (this.screenFlash > 0) {
            this.gameCtx.fillStyle = `rgba(255, 255, 255, ${this.screenFlash})`;
            this.gameCtx.fillRect(0, 0, BREAKOUT.WIDTH, BREAKOUT.HEIGHT);
        }
    }
    
    drawGradientBackground() {
        // Enhanced animated background
        const gradient = this.gameCtx.createRadialGradient(
            BREAKOUT.WIDTH / 2, BREAKOUT.HEIGHT / 2, 0,
            BREAKOUT.WIDTH / 2, BREAKOUT.HEIGHT / 2, BREAKOUT.WIDTH
        );
        
        // Animated color shifts
        const pulse = Math.sin(this.animationTime * 0.5) * 0.1;
        const r1 = Math.floor(15 + pulse * 10);
        const g1 = Math.floor(15 + pulse * 10);
        const b1 = Math.floor(35 + pulse * 20);
        
        gradient.addColorStop(0, `rgb(${r1}, ${g1}, ${b1})`);
        gradient.addColorStop(0.7, BREAKOUT.COLORS.GAME.BACKGROUND);
        gradient.addColorStop(1, '#0a0a20');
        
        this.gameCtx.fillStyle = gradient;
        this.gameCtx.fillRect(0, 0, BREAKOUT.WIDTH, BREAKOUT.HEIGHT);
        
        // Draw animated energy waves
        this.drawEnergyWaves();
    }
    
    /**
     * Draw animated energy waves and geometric elements
     */
    drawEnergyWaves() {
        this.gameCtx.save();
        
        this.energyWaves.forEach(wave => {
            if (wave.type === 'circle') {
                // Floating geometric elements
                const pulse = Math.sin(wave.pulsePhase) * 0.3 + 0.7;
                this.gameCtx.globalAlpha = wave.opacity * pulse;
                
                this.gameCtx.save();
                this.gameCtx.translate(wave.x, wave.y);
                this.gameCtx.rotate(wave.rotation);
                
                // Create gradient for depth
                const gradient = this.gameCtx.createRadialGradient(0, 0, 0, 0, 0, wave.radius * pulse);
                gradient.addColorStop(0, wave.color);
                gradient.addColorStop(0.7, wave.color.replace('40%)', '20%)'));
                gradient.addColorStop(1, 'transparent');
                
                this.gameCtx.fillStyle = gradient;
                this.gameCtx.beginPath();
                this.gameCtx.arc(0, 0, wave.radius * pulse, 0, Math.PI * 2);
                this.gameCtx.fill();
                
                // Add inner ring
                this.gameCtx.strokeStyle = wave.color;
                this.gameCtx.lineWidth = 1;
                this.gameCtx.beginPath();
                this.gameCtx.arc(0, 0, wave.radius * pulse * 0.6, 0, Math.PI * 2);
                this.gameCtx.stroke();
                
                this.gameCtx.restore();
            } else {
                // Flowing energy streams
                this.gameCtx.globalAlpha = wave.opacity;
                this.gameCtx.strokeStyle = wave.color;
                this.gameCtx.lineWidth = wave.width;
                this.gameCtx.lineCap = 'round';
                
                // Create flowing sine wave
                this.gameCtx.beginPath();
                let started = false;
                
                for (let x = 0; x <= BREAKOUT.WIDTH; x += 5) {
                    const waveY = wave.y + Math.sin(x * wave.frequency + wave.phase) * wave.amplitude;
                    
                    if (waveY >= -10 && waveY <= BREAKOUT.HEIGHT + 10) {
                        if (!started) {
                            this.gameCtx.moveTo(wave.x + x - BREAKOUT.WIDTH/2, waveY);
                            started = true;
                        } else {
                            this.gameCtx.lineTo(wave.x + x - BREAKOUT.WIDTH/2, waveY);
                        }
                    }
                }
                
                this.gameCtx.stroke();
                
                // Add glow effect
                this.gameCtx.shadowColor = wave.color;
                this.gameCtx.shadowBlur = 10;
                this.gameCtx.stroke();
                this.gameCtx.shadowBlur = 0;
            }
        });
        
        this.gameCtx.restore();
    }
    
    drawGameObjects() {
        // Only draw if game objects exist
        if (!this.ball || !this.paddle) return;
        
        // Draw ball trail
        if (this.ball.trail.length > 1) {
            this.gameCtx.strokeStyle = BREAKOUT.COLORS.GAME.BALL_TRAIL;
            this.gameCtx.lineWidth = 3;
            this.gameCtx.globalAlpha = 0.6;
            
            this.gameCtx.beginPath();
            this.gameCtx.moveTo(this.ball.trail[0].x, this.ball.trail[0].y);
            for (let i = 1; i < this.ball.trail.length; i++) {
                this.gameCtx.lineTo(this.ball.trail[i].x, this.ball.trail[i].y);
            }
            this.gameCtx.stroke();
            this.gameCtx.globalAlpha = 1;
        }
        
        // Draw paddle
        this.drawPaddle();
        
        // Draw ball
        this.drawBall();
        
        // Draw bricks
        this.bricks.forEach(brick => {
            if (!brick.destroyed) {
                this.drawBrick(brick);
            }
        });
    }
    
    drawPaddle() {
        this.gameCtx.save();
        
        const paddle = this.paddle;
        const radius = paddle.height / 2;
        
        // Audio-reactive glow
        if (this.audioVisualizer.paddleGlow > 0.1) {
            this.gameCtx.shadowColor = BREAKOUT.COLORS.GAME.PADDLE_GLOW;
            this.gameCtx.shadowBlur = this.audioVisualizer.paddleGlow * 25;
        }
        
        // 3D-style paddle with multiple gradients
        // Base shadow
        this.gameCtx.fillStyle = 'rgba(0, 0, 0, 0.3)';
        this.drawRoundedRect(this.gameCtx, paddle.x + 2, paddle.y + 2, paddle.width, paddle.height, radius);
        this.gameCtx.fill();
        
        // Main body gradient (top to bottom)
        const mainGradient = this.gameCtx.createLinearGradient(
            paddle.x, paddle.y,
            paddle.x, paddle.y + paddle.height
        );
        mainGradient.addColorStop(0, '#00f0ff');
        mainGradient.addColorStop(0.3, BREAKOUT.COLORS.GAME.PADDLE);
        mainGradient.addColorStop(0.7, BREAKOUT.COLORS.GAME.PADDLE_GLOW);
        mainGradient.addColorStop(1, '#006699');
        
        this.gameCtx.fillStyle = mainGradient;
        this.drawRoundedRect(this.gameCtx, paddle.x, paddle.y, paddle.width, paddle.height, radius);
        this.gameCtx.fill();
        
        // Top highlight
        const highlightGradient = this.gameCtx.createLinearGradient(
            paddle.x, paddle.y,
            paddle.x, paddle.y + paddle.height * 0.4
        );
        highlightGradient.addColorStop(0, 'rgba(255, 255, 255, 0.6)');
        highlightGradient.addColorStop(1, 'rgba(255, 255, 255, 0)');
        
        this.gameCtx.fillStyle = highlightGradient;
        this.drawRoundedRect(this.gameCtx, paddle.x, paddle.y, paddle.width, paddle.height * 0.4, radius);
        this.gameCtx.fill();
        
        // Border
        this.gameCtx.strokeStyle = '#003366';
        this.gameCtx.lineWidth = 1;
        this.drawRoundedRect(this.gameCtx, paddle.x, paddle.y, paddle.width, paddle.height, radius);
        this.gameCtx.stroke();
        
        this.gameCtx.restore();
    }
    
    drawBall() {
        this.gameCtx.save();
        
        // Audio-reactive glow
        if (this.audioVisualizer.ballGlow > 0.1) {
            this.gameCtx.shadowColor = BREAKOUT.COLORS.GAME.BALL;
            this.gameCtx.shadowBlur = this.audioVisualizer.ballGlow * 20;
        }
        
        // 3D sphere effect with radial gradient
        const ballGradient = this.gameCtx.createRadialGradient(
            this.ball.x - 2, this.ball.y - 2, 1,
            this.ball.x, this.ball.y, BREAKOUT.VISUAL.BALL_RADIUS
        );
        ballGradient.addColorStop(0, '#ffffff');
        ballGradient.addColorStop(0.3, '#f0f0f0');
        ballGradient.addColorStop(0.7, BREAKOUT.COLORS.GAME.BALL);
        ballGradient.addColorStop(1, '#cccccc');
        
        this.gameCtx.fillStyle = ballGradient;
        this.gameCtx.beginPath();
        this.gameCtx.arc(this.ball.x, this.ball.y, BREAKOUT.VISUAL.BALL_RADIUS, 0, Math.PI * 2);
        this.gameCtx.fill();
        
        // Highlight
        const highlightGradient = this.gameCtx.createRadialGradient(
            this.ball.x - 3, this.ball.y - 3, 0,
            this.ball.x - 3, this.ball.y - 3, 4
        );
        highlightGradient.addColorStop(0, 'rgba(255, 255, 255, 0.8)');
        highlightGradient.addColorStop(1, 'rgba(255, 255, 255, 0)');
        
        this.gameCtx.fillStyle = highlightGradient;
        this.gameCtx.beginPath();
        this.gameCtx.arc(this.ball.x - 3, this.ball.y - 3, 4, 0, Math.PI * 2);
        this.gameCtx.fill();
        
        this.gameCtx.restore();
    }
    
    drawBrick(brick) {
        this.gameCtx.save();
        
        const radius = 4;
        
        // Drop shadow
        this.gameCtx.fillStyle = 'rgba(0, 0, 0, 0.2)';
        this.drawRoundedRect(this.gameCtx, brick.x + 1, brick.y + 1, brick.width, brick.height, radius);
        this.gameCtx.fill();
        
        // Main brick gradient (3D effect)
        const gradient = this.gameCtx.createLinearGradient(
            brick.x, brick.y,
            brick.x, brick.y + brick.height
        );
        
        const baseColor = brick.color;
        const lightColor = this.lightenColor(baseColor, 0.3);
        const darkColor = this.darkenColor(baseColor, 0.2);
        
        gradient.addColorStop(0, lightColor);
        gradient.addColorStop(0.4, baseColor);
        gradient.addColorStop(1, darkColor);
        
        this.gameCtx.fillStyle = gradient;
        this.drawRoundedRect(this.gameCtx, brick.x, brick.y, brick.width, brick.height, radius);
        this.gameCtx.fill();
        
        // Top highlight
        const highlightGradient = this.gameCtx.createLinearGradient(
            brick.x, brick.y,
            brick.x, brick.y + brick.height * 0.3
        );
        highlightGradient.addColorStop(0, 'rgba(255, 255, 255, 0.4)');
        highlightGradient.addColorStop(1, 'rgba(255, 255, 255, 0)');
        
        this.gameCtx.fillStyle = highlightGradient;
        this.drawRoundedRect(this.gameCtx, brick.x, brick.y, brick.width, brick.height * 0.3, radius);
        this.gameCtx.fill();
        
        // Border
        this.gameCtx.strokeStyle = this.darkenColor(baseColor, 0.4);
        this.gameCtx.lineWidth = 1;
        this.drawRoundedRect(this.gameCtx, brick.x, brick.y, brick.width, brick.height, radius);
        this.gameCtx.stroke();
        
        this.gameCtx.restore();
    }
    
    drawParticles() {
        this.gameCtx.save();
        
        this.particles.forEach(particle => {
            const alpha = particle.life / particle.maxLife;
            this.gameCtx.globalAlpha = alpha;
            
            this.gameCtx.save();
            this.gameCtx.translate(particle.x, particle.y);
            this.gameCtx.rotate(particle.rotation);
            
            // Gradient for each particle
            const particleGradient = this.gameCtx.createRadialGradient(
                0, 0, 0,
                0, 0, particle.size
            );
            particleGradient.addColorStop(0, particle.color || BREAKOUT.COLORS.GAME.PARTICLE);
            particleGradient.addColorStop(1, 'rgba(0, 0, 0, 0)');
            
            this.gameCtx.fillStyle = particleGradient;
            this.gameCtx.fillRect(-particle.size, -particle.size, particle.size * 2, particle.size * 2);
            
            this.gameCtx.restore();
        });
        
        this.gameCtx.restore();
    }
    
    /**
     * GUI Layer Rendering
     * 
     * ActionEngine's GUI layer for UI elements and overlays.
     */
    drawGUILayer() {
        this.guiCtx.clearRect(0, 0, BREAKOUT.WIDTH, BREAKOUT.HEIGHT);
        
        if (this.gameState === 'startScreen') {
            this.drawStartScreen();
        } else {
            this.drawHUD();
            
            if (this.gameState === 'gameOver') {
                this.drawGameOver();
            } else if (this.gameState === 'victory') {
                this.drawVictory();
            } else if (this.gameState === 'ballLost') {
                this.drawBallLostMessage();
            }
        }
    }
    
    drawHUD() {
        // HUD background
        this.guiCtx.fillStyle = BREAKOUT.COLORS.GUI.HUD_BG;
        this.guiCtx.fillRect(0, 0, BREAKOUT.WIDTH, 50);
        
        // Game stats
        this.guiCtx.fillStyle = BREAKOUT.COLORS.GUI.TEXT;
        this.guiCtx.font = '20px Arial';
        this.guiCtx.textAlign = 'left';
        
        this.guiCtx.fillText(`Score: ${this.score}`, BREAKOUT.UI.HUD_MARGIN, 25);
        this.guiCtx.fillText(`Lives: ${this.lives}`, BREAKOUT.UI.HUD_MARGIN, 45);
        
        this.guiCtx.textAlign = 'right';
        this.guiCtx.fillText(`Level: ${this.level}`, BREAKOUT.WIDTH - BREAKOUT.UI.HUD_MARGIN, 25);
    }
    
    drawStartScreen() {
        // Title
        this.guiCtx.fillStyle = BREAKOUT.COLORS.GUI.TEXT;
        this.guiCtx.font = 'bold 48px Arial';
        this.guiCtx.textAlign = 'center';
        this.guiCtx.fillText('BREAKOUT', BREAKOUT.WIDTH / 2, BREAKOUT.HEIGHT / 2 - 80);
        
        // Subtitle
        this.guiCtx.font = '20px Arial';
        this.guiCtx.fillStyle = '#aaaaaa';
        this.guiCtx.fillText('ActionEngine Audio System Demo', BREAKOUT.WIDTH / 2, BREAKOUT.HEIGHT / 2 - 10);
        
        // Enhanced start button
        const button = this.startButton;
        this.drawEnhancedButton(this.guiCtx, button, 'START GAME');
        
        // Instructions
        this.guiCtx.fillStyle = '#888888';
        this.guiCtx.font = '16px Arial';
        this.guiCtx.fillText('Click button or press Action1 to start', BREAKOUT.WIDTH / 2, button.y + button.height + 40);
        
        // Game instructions
        this.guiCtx.font = '14px Arial';
        const instructions = [
            'Arrow Keys: Move Paddle  Action1: Launch Ball  Action2: Volume',
            'Action3: Stop All Sounds  ActionDebugToggle: Debug Audio Info'
        ];
        
        instructions.forEach((instruction, i) => {
            this.guiCtx.fillText(instruction, BREAKOUT.WIDTH / 2, BREAKOUT.HEIGHT - 80 + i * 18);
        });
    }
    
    drawGameOver() {
        // Overlay
        this.guiCtx.fillStyle = 'rgba(0, 0, 0, 0.8)';
        this.guiCtx.fillRect(0, 0, BREAKOUT.WIDTH, BREAKOUT.HEIGHT);
        
        // Game over text
        this.guiCtx.fillStyle = '#ff4444';
        this.guiCtx.font = 'bold 48px Arial';
        this.guiCtx.textAlign = 'center';
        this.guiCtx.fillText('GAME OVER', BREAKOUT.WIDTH / 2, BREAKOUT.HEIGHT / 2 - 50);
        
        // Stats
        this.guiCtx.fillStyle = BREAKOUT.COLORS.GUI.TEXT;
        this.guiCtx.font = '24px Arial';
        this.guiCtx.fillText(`Final Score: ${this.score}`, BREAKOUT.WIDTH / 2, BREAKOUT.HEIGHT / 2);
        this.guiCtx.fillText(`Level Reached: ${this.level}`, BREAKOUT.WIDTH / 2, BREAKOUT.HEIGHT / 2 + 30);
        
        // Restart instruction
        this.guiCtx.font = '18px Arial';
        this.guiCtx.fillStyle = '#888888';
        this.guiCtx.fillText('Press Action1 to restart', BREAKOUT.WIDTH / 2, BREAKOUT.HEIGHT / 2 + 80);
    }
    
    drawVictory() {
        // Victory overlay
        this.guiCtx.fillStyle = 'rgba(0, 50, 0, 0.8)';
        this.guiCtx.fillRect(0, 0, BREAKOUT.WIDTH, BREAKOUT.HEIGHT);
        
        // Victory text
        this.guiCtx.fillStyle = '#44ff44';
        this.guiCtx.font = 'bold 48px Arial';
        this.guiCtx.textAlign = 'center';
        this.guiCtx.fillText('LEVEL COMPLETE!', BREAKOUT.WIDTH / 2, BREAKOUT.HEIGHT / 2 - 50);
        
        // Stats
        this.guiCtx.fillStyle = BREAKOUT.COLORS.GUI.TEXT;
        this.guiCtx.font = '24px Arial';
        this.guiCtx.fillText(`Score: ${this.score}`, BREAKOUT.WIDTH / 2, BREAKOUT.HEIGHT / 2);
        this.guiCtx.fillText(`Level ${this.level} Complete!`, BREAKOUT.WIDTH / 2, BREAKOUT.HEIGHT / 2 + 30);
        
        // Continue instruction
        this.guiCtx.font = '18px Arial';
        this.guiCtx.fillStyle = '#888888';
        this.guiCtx.fillText('Press Action1 to continue', BREAKOUT.WIDTH / 2, BREAKOUT.HEIGHT / 2 + 80);
    }
    
    drawBallLostMessage() {
        this.guiCtx.fillStyle = 'rgba(100, 0, 0, 0.7)';
        this.guiCtx.fillRect(0, BREAKOUT.HEIGHT / 2 - 40, BREAKOUT.WIDTH, 80);
        
        this.guiCtx.fillStyle = '#ff6666';
        this.guiCtx.font = 'bold 32px Arial';
        this.guiCtx.textAlign = 'center';
        this.guiCtx.fillText('BALL LOST!', BREAKOUT.WIDTH / 2, BREAKOUT.HEIGHT / 2 - 10);
        
        this.guiCtx.fillStyle = BREAKOUT.COLORS.GUI.TEXT;
        this.guiCtx.font = '18px Arial';
        this.guiCtx.fillText(`${this.lives} lives remaining`, BREAKOUT.WIDTH / 2, BREAKOUT.HEIGHT / 2 + 15);
    }
    
    /**
     * Debug Layer Rendering
     * 
     * ActionEngine's debug layer for development information.
     * This demo focuses on audio system debugging.
     */
    drawDebugLayer() {
        // Always clear first
        this.debugCtx.clearRect(0, 0, BREAKOUT.WIDTH, BREAKOUT.HEIGHT);
        
        // Only draw when debug overlay is visible (toggled with ActionDebugToggle)
        if (!this.debugOverlayVisible) return;
        
        const panel = BREAKOUT.UI.DEBUG_PANEL;
        
        // Debug panel background
        this.debugCtx.fillStyle = BREAKOUT.COLORS.DEBUG.BACKGROUND;
        this.debugCtx.fillRect(panel.x, panel.y, panel.width, panel.height);
        
        // Debug info
        this.debugCtx.fillStyle = BREAKOUT.COLORS.DEBUG.TEXT;
        this.debugCtx.font = '14px monospace';
        this.debugCtx.textAlign = 'left';
        
        const debugInfo = [
            'ActionEngine Audio System Debug',
            '',
            'SYNTHESIS TYPES IN USE:',
            ' Sweep: Frequency sweeps (paddle, walls)',
            ' Complex: Multi-oscillator (bricks, victory)',
            ' FM: Frequency modulation (special effects)',
            ' Noise: Filtered noise (explosions, impacts)',
            ' MIDI: Sampled instruments (music)',
            '',
            'AUDIO FEATURES:',
            ' Automatic sound stacking prevention',
            ' Individual volume control per sound',
            ' Sound completion callbacks',
            '',
            'RECENT SOUND EVENTS:'
        ];
        
        debugInfo.forEach((line, i) => {
            this.debugCtx.fillText(line, panel.x + 10, panel.y + 25 + i * 16);
        });
        
        // Recent sound history
        this.soundHistory.forEach((event, i) => {
            if (i < 8) { // Limit display
                this.debugCtx.fillStyle = i === 0 ? BREAKOUT.COLORS.DEBUG.HIGHLIGHT : BREAKOUT.COLORS.DEBUG.TEXT;
                this.debugCtx.fillText(event, panel.x + 10, panel.y + 25 + (debugInfo.length + i) * 16);
            }
        });
    }
    
    /******* UTILITY FUNCTIONS *******/
    
    /**
     * Enhanced button drawing with 3D effect
     */
    drawEnhancedButton(ctx, button, text) {
        ctx.save();
        
        const radius = 8;
        const depth = 4;
        
        // Button shadow
        ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
        this.drawRoundedRect(ctx, button.x + depth, button.y + depth, button.width, button.height, radius);
        ctx.fill();
        
        // Button gradient
        const gradient = ctx.createLinearGradient(
            button.x, button.y,
            button.x, button.y + button.height
        );
        
        if (button.hovered) {
            gradient.addColorStop(0, '#00f0ff');
            gradient.addColorStop(0.5, BREAKOUT.COLORS.GUI.BUTTON_HOVER);
            gradient.addColorStop(1, '#0088cc');
        } else {
            gradient.addColorStop(0, '#00d4ff');
            gradient.addColorStop(0.5, BREAKOUT.COLORS.GUI.BUTTON_ACTIVE);
            gradient.addColorStop(1, '#0099cc');
        }
        
        ctx.fillStyle = gradient;
        this.drawRoundedRect(ctx, button.x, button.y, button.width, button.height, radius);
        ctx.fill();
        
        // Button highlight
        const highlightGradient = ctx.createLinearGradient(
            button.x, button.y,
            button.x, button.y + button.height * 0.5
        );
        highlightGradient.addColorStop(0, 'rgba(255, 255, 255, 0.4)');
        highlightGradient.addColorStop(1, 'rgba(255, 255, 255, 0)');
        
        ctx.fillStyle = highlightGradient;
        this.drawRoundedRect(ctx, button.x, button.y, button.width, button.height * 0.5, radius);
        ctx.fill();
        
        // Button border
        ctx.strokeStyle = '#003366';
        ctx.lineWidth = 2;
        this.drawRoundedRect(ctx, button.x, button.y, button.width, button.height, radius);
        ctx.stroke();
        
        // Button text with shadow
        ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
        ctx.font = 'bold 24px Arial';
        ctx.textAlign = 'center';
        ctx.fillText(text, button.x + button.width / 2 + 1, button.y + button.height / 2 + 9);
        
        ctx.fillStyle = BREAKOUT.COLORS.GUI.TEXT;
        ctx.fillText(text, button.x + button.width / 2, button.y + button.height / 2 + 8);
        
        ctx.restore();
    }
    
    /**
     * Utility function to darken colors for visual effects
     */
    darkenColor(color, factor) {
        const hex = color.replace('#', '');
        const r = Math.max(0, parseInt(hex.substr(0, 2), 16) * (1 - factor));
        const g = Math.max(0, parseInt(hex.substr(2, 2), 16) * (1 - factor));
        const b = Math.max(0, parseInt(hex.substr(4, 2), 16) * (1 - factor));
        
        return `rgb(${Math.floor(r)}, ${Math.floor(g)}, ${Math.floor(b)})`;
    }
    
    /**
     * Utility function to lighten colors for visual effects
     */
    lightenColor(color, factor) {
        const hex = color.replace('#', '');
        const r = Math.min(255, parseInt(hex.substr(0, 2), 16) + (255 - parseInt(hex.substr(0, 2), 16)) * factor);
        const g = Math.min(255, parseInt(hex.substr(2, 2), 16) + (255 - parseInt(hex.substr(2, 2), 16)) * factor);
        const b = Math.min(255, parseInt(hex.substr(4, 2), 16) + (255 - parseInt(hex.substr(4, 2), 16)) * factor);
        
        return `rgb(${Math.floor(r)}, ${Math.floor(g)}, ${Math.floor(b)})`;
    }
}
```

Now that you've studied how ActionEngine works your TASK is to make a game by creating your own custom `Game` class.

The key insight you have gained is that the demos show the PATTERNS for creating games in ActionEngineJS.

Upon detailed inspection you see that the demos are showing the required patterns for working with the EXTERNAL LIBRARY'S input, audio, and canvas systems.

You should assume that the user's envrionment is pre-configured, and your TASK is to provide the `Game` class which will slot in the externally existing ecosystem.

Your challenge is that to you, ActionEngine as a library is a black box, so you must follow the PATTERN of the provided demos to ensure that you work within the provided API examples and you WILL NOT make assumptions about any API except for those that have been documented above.

Your purpose is to COMPLETE THE TASK of creating a NEW GAME in the ActionEngine framework.

Additonal classes which complement the Game class are encouraged. You feel very confident that because of the documentation provided to you, you will be able to make ANOTHER GAME using the APIs available and referenced in the demos.

Structure the game around core foundational data points and state management. Each game element should have clear, well-defined properties that serve as single sources of truth (position, velocity, state, etc.). Use consistent data structures that can be easily referenced, modified, and extended.

The codebase should be lean but complete - every variable and function should serve an immediate purpose while maintaining clean interfaces for future expansion.

I don't want you to replicate any sytlistic or design decisions from the demos. Their intended purpose is to document and help explain how to interface with ActionEngine's API. How the NEW GAME looks, plays, and sounds is up to you, so let your creativity flourish.

Your TASK is to work within the constraints of ActionEngine and make a NEW GAME.

Tell me how much sense everything makes to you and how you understand the concept and the ActionEngine API.

Tell me how you understand that while ActionEngine enforces restrictions regarding input, canvas management, and audio, it will actually allow the focus to be on the creativity required to make an impressive, complete and fun game.

Tell me you're excited to work with ActionEngine.

Then ask me what game we are going to make.